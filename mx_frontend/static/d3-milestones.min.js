(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = global || self, global.milestones = factory());
  }(this, (function () { 'use strict';
  
    function _iterableToArrayLimit(arr, i) {
      var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
      if (null != _i) {
        var _s,
          _e,
          _x,
          _r,
          _arr = [],
          _n = !0,
          _d = !1;
        try {
          if (_x = (_i = _i.call(arr)).next, 0 === i) {
            if (Object(_i) !== _i) return;
            _n = !1;
          } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);
        } catch (err) {
          _d = !0, _e = err;
        } finally {
          try {
            if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;
          } finally {
            if (_d) throw _e;
          }
        }
        return _arr;
      }
    }
    function _regeneratorRuntime() {
      _regeneratorRuntime = function () {
        return exports;
      };
      var exports = {},
        Op = Object.prototype,
        hasOwn = Op.hasOwnProperty,
        defineProperty = Object.defineProperty || function (obj, key, desc) {
          obj[key] = desc.value;
        },
        $Symbol = "function" == typeof Symbol ? Symbol : {},
        iteratorSymbol = $Symbol.iterator || "@@iterator",
        asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
        toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
      function define(obj, key, value) {
        return Object.defineProperty(obj, key, {
          value: value,
          enumerable: !0,
          configurable: !0,
          writable: !0
        }), obj[key];
      }
      try {
        define({}, "");
      } catch (err) {
        define = function (obj, key, value) {
          return obj[key] = value;
        };
      }
      function wrap(innerFn, outerFn, self, tryLocsList) {
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
          generator = Object.create(protoGenerator.prototype),
          context = new Context(tryLocsList || []);
        return defineProperty(generator, "_invoke", {
          value: makeInvokeMethod(innerFn, self, context)
        }), generator;
      }
      function tryCatch(fn, obj, arg) {
        try {
          return {
            type: "normal",
            arg: fn.call(obj, arg)
          };
        } catch (err) {
          return {
            type: "throw",
            arg: err
          };
        }
      }
      exports.wrap = wrap;
      var ContinueSentinel = {};
      function Generator() {}
      function GeneratorFunction() {}
      function GeneratorFunctionPrototype() {}
      var IteratorPrototype = {};
      define(IteratorPrototype, iteratorSymbol, function () {
        return this;
      });
      var getProto = Object.getPrototypeOf,
        NativeIteratorPrototype = getProto && getProto(getProto(values([])));
      NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function (method) {
          define(prototype, method, function (arg) {
            return this._invoke(method, arg);
          });
        });
      }
      function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve, reject) {
          var record = tryCatch(generator[method], generator, arg);
          if ("throw" !== record.type) {
            var result = record.arg,
              value = result.value;
            return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
              invoke("next", value, resolve, reject);
            }, function (err) {
              invoke("throw", err, resolve, reject);
            }) : PromiseImpl.resolve(value).then(function (unwrapped) {
              result.value = unwrapped, resolve(result);
            }, function (error) {
              return invoke("throw", error, resolve, reject);
            });
          }
          reject(record.arg);
        }
        var previousPromise;
        defineProperty(this, "_invoke", {
          value: function (method, arg) {
            function callInvokeWithMethodAndArg() {
              return new PromiseImpl(function (resolve, reject) {
                invoke(method, arg, resolve, reject);
              });
            }
            return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
          }
        });
      }
      function makeInvokeMethod(innerFn, self, context) {
        var state = "suspendedStart";
        return function (method, arg) {
          if ("executing" === state) throw new Error("Generator is already running");
          if ("completed" === state) {
            if ("throw" === method) throw arg;
            return doneResult();
          }
          for (context.method = method, context.arg = arg;;) {
            var delegate = context.delegate;
            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context);
              if (delegateResult) {
                if (delegateResult === ContinueSentinel) continue;
                return delegateResult;
              }
            }
            if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
              if ("suspendedStart" === state) throw state = "completed", context.arg;
              context.dispatchException(context.arg);
            } else "return" === context.method && context.abrupt("return", context.arg);
            state = "executing";
            var record = tryCatch(innerFn, self, context);
            if ("normal" === record.type) {
              if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
              return {
                value: record.arg,
                done: context.done
              };
            }
            "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
          }
        };
      }
      function maybeInvokeDelegate(delegate, context) {
        var methodName = context.method,
          method = delegate.iterator[methodName];
        if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
        var record = tryCatch(method, delegate.iterator, context.arg);
        if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
        var info = record.arg;
        return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
      }
      function pushTryEntry(locs) {
        var entry = {
          tryLoc: locs[0]
        };
        1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
      }
      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal", delete record.arg, entry.completion = record;
      }
      function Context(tryLocsList) {
        this.tryEntries = [{
          tryLoc: "root"
        }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
      }
      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];
          if (iteratorMethod) return iteratorMethod.call(iterable);
          if ("function" == typeof iterable.next) return iterable;
          if (!isNaN(iterable.length)) {
            var i = -1,
              next = function next() {
                for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
                return next.value = undefined, next.done = !0, next;
              };
            return next.next = next;
          }
        }
        return {
          next: doneResult
        };
      }
      function doneResult() {
        return {
          value: undefined,
          done: !0
        };
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
        value: GeneratorFunctionPrototype,
        configurable: !0
      }), defineProperty(GeneratorFunctionPrototype, "constructor", {
        value: GeneratorFunction,
        configurable: !0
      }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
        var ctor = "function" == typeof genFun && genFun.constructor;
        return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
      }, exports.mark = function (genFun) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
      }, exports.awrap = function (arg) {
        return {
          __await: arg
        };
      }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
        return this;
      }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
        void 0 === PromiseImpl && (PromiseImpl = Promise);
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
        return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
          return result.done ? result.value : iter.next();
        });
      }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
        return this;
      }), define(Gp, "toString", function () {
        return "[object Generator]";
      }), exports.keys = function (val) {
        var object = Object(val),
          keys = [];
        for (var key in object) keys.push(key);
        return keys.reverse(), function next() {
          for (; keys.length;) {
            var key = keys.pop();
            if (key in object) return next.value = key, next.done = !1, next;
          }
          return next.done = !0, next;
        };
      }, exports.values = values, Context.prototype = {
        constructor: Context,
        reset: function (skipTempReset) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
        },
        stop: function () {
          this.done = !0;
          var rootRecord = this.tryEntries[0].completion;
          if ("throw" === rootRecord.type) throw rootRecord.arg;
          return this.rval;
        },
        dispatchException: function (exception) {
          if (this.done) throw exception;
          var context = this;
          function handle(loc, caught) {
            return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
          }
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i],
              record = entry.completion;
            if ("root" === entry.tryLoc) return handle("end");
            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc"),
                hasFinally = hasOwn.call(entry, "finallyLoc");
              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
                if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
              } else {
                if (!hasFinally) throw new Error("try statement without catch or finally");
                if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
              }
            }
          }
        },
        abrupt: function (type, arg) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }
          finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
          var record = finallyEntry ? finallyEntry.completion : {};
          return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
        },
        complete: function (record, afterLoc) {
          if ("throw" === record.type) throw record.arg;
          return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
        },
        finish: function (finallyLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
          }
        },
        catch: function (tryLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;
              if ("throw" === record.type) {
                var thrown = record.arg;
                resetTryEntry(entry);
              }
              return thrown;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield: function (iterable, resultName, nextLoc) {
          return this.delegate = {
            iterator: values(iterable),
            resultName: resultName,
            nextLoc: nextLoc
          }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
        }
      }, exports;
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
  
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
        return typeof obj;
      } : function (obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      }, _typeof(obj);
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
      return arr2;
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it) o = it;
          var i = 0;
          var F = function () {};
          return {
            s: F,
            n: function () {
              if (i >= o.length) return {
                done: true
              };
              return {
                done: false,
                value: o[i++]
              };
            },
            e: function (e) {
              throw e;
            },
            f: F
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true,
        didErr = false,
        err;
      return {
        s: function () {
          it = it.call(o);
        },
        n: function () {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        },
        e: function (e) {
          didErr = true;
          err = e;
        },
        f: function () {
          try {
            if (!normalCompletion && it.return != null) it.return();
          } finally {
            if (didErr) throw err;
          }
        }
      };
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
  
    var xhtml = "http://www.w3.org/1999/xhtml";
    var namespaces = {
      svg: "http://www.w3.org/2000/svg",
      xhtml: xhtml,
      xlink: "http://www.w3.org/1999/xlink",
      xml: "http://www.w3.org/XML/1998/namespace",
      xmlns: "http://www.w3.org/2000/xmlns/"
    };
  
    function namespace (name) {
      var prefix = name += "",
        i = prefix.indexOf(":");
      if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
      return namespaces.hasOwnProperty(prefix) ? {
        space: namespaces[prefix],
        local: name
      } : name; // eslint-disable-line no-prototype-builtins
    }
  
    function creatorInherit(name) {
      return function () {
        var document = this.ownerDocument,
          uri = this.namespaceURI;
        return uri === xhtml && document.documentElement.namespaceURI === xhtml ? document.createElement(name) : document.createElementNS(uri, name);
      };
    }
    function creatorFixed(fullname) {
      return function () {
        return this.ownerDocument.createElementNS(fullname.space, fullname.local);
      };
    }
    function creator (name) {
      var fullname = namespace(name);
      return (fullname.local ? creatorFixed : creatorInherit)(fullname);
    }
  
    function none() {}
    function selector (selector) {
      return selector == null ? none : function () {
        return this.querySelector(selector);
      };
    }
  
    function selection_select (select) {
      if (typeof select !== "function") select = selector(select);
      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
          if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
            if ("__data__" in node) subnode.__data__ = node.__data__;
            subgroup[i] = subnode;
          }
        }
      }
      return new Selection(subgroups, this._parents);
    }
  
    // Given something array like (or null), returns something that is strictly an
    // array. This is used to ensure that array-like objects passed to d3.selectAll
    // or selection.selectAll are converted into proper arrays when creating a
    // selection; we don’t ever want to create a selection backed by a live
    // HTMLCollection or NodeList. However, note that selection.selectAll will use a
    // static NodeList as a group, since it safely derived from querySelectorAll.
    function array(x) {
      return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
    }
  
    function empty() {
      return [];
    }
    function selectorAll (selector) {
      return selector == null ? empty : function () {
        return this.querySelectorAll(selector);
      };
    }
  
    function arrayAll(select) {
      return function () {
        return array(select.apply(this, arguments));
      };
    }
    function selection_selectAll (select) {
      if (typeof select === "function") select = arrayAll(select);else select = selectorAll(select);
      for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            subgroups.push(select.call(node, node.__data__, i, group));
            parents.push(node);
          }
        }
      }
      return new Selection(subgroups, parents);
    }
  
    function matcher (selector) {
      return function () {
        return this.matches(selector);
      };
    }
    function childMatcher(selector) {
      return function (node) {
        return node.matches(selector);
      };
    }
  
    var find = Array.prototype.find;
    function childFind(match) {
      return function () {
        return find.call(this.children, match);
      };
    }
    function childFirst() {
      return this.firstElementChild;
    }
    function selection_selectChild (match) {
      return this.select(match == null ? childFirst : childFind(typeof match === "function" ? match : childMatcher(match)));
    }
  
    var filter = Array.prototype.filter;
    function children() {
      return Array.from(this.children);
    }
    function childrenFilter(match) {
      return function () {
        return filter.call(this.children, match);
      };
    }
    function selection_selectChildren (match) {
      return this.selectAll(match == null ? children : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
    }
  
    function selection_filter (match) {
      if (typeof match !== "function") match = matcher(match);
      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
          if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
            subgroup.push(node);
          }
        }
      }
      return new Selection(subgroups, this._parents);
    }
  
    function sparse (update) {
      return new Array(update.length);
    }
  
    function selection_enter () {
      return new Selection(this._enter || this._groups.map(sparse), this._parents);
    }
    function EnterNode(parent, datum) {
      this.ownerDocument = parent.ownerDocument;
      this.namespaceURI = parent.namespaceURI;
      this._next = null;
      this._parent = parent;
      this.__data__ = datum;
    }
    EnterNode.prototype = {
      constructor: EnterNode,
      appendChild: function appendChild(child) {
        return this._parent.insertBefore(child, this._next);
      },
      insertBefore: function insertBefore(child, next) {
        return this._parent.insertBefore(child, next);
      },
      querySelector: function querySelector(selector) {
        return this._parent.querySelector(selector);
      },
      querySelectorAll: function querySelectorAll(selector) {
        return this._parent.querySelectorAll(selector);
      }
    };
  
    function constant (x) {
      return function () {
        return x;
      };
    }
  
    function bindIndex(parent, group, enter, update, exit, data) {
      var i = 0,
        node,
        groupLength = group.length,
        dataLength = data.length;
  
      // Put any non-null nodes that fit into update.
      // Put any null nodes into enter.
      // Put any remaining data into enter.
      for (; i < dataLength; ++i) {
        if (node = group[i]) {
          node.__data__ = data[i];
          update[i] = node;
        } else {
          enter[i] = new EnterNode(parent, data[i]);
        }
      }
  
      // Put any non-null nodes that don’t fit into exit.
      for (; i < groupLength; ++i) {
        if (node = group[i]) {
          exit[i] = node;
        }
      }
    }
    function bindKey(parent, group, enter, update, exit, data, key) {
      var i,
        node,
        nodeByKeyValue = new Map(),
        groupLength = group.length,
        dataLength = data.length,
        keyValues = new Array(groupLength),
        keyValue;
  
      // Compute the key for each node.
      // If multiple nodes have the same key, the duplicates are added to exit.
      for (i = 0; i < groupLength; ++i) {
        if (node = group[i]) {
          keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
          if (nodeByKeyValue.has(keyValue)) {
            exit[i] = node;
          } else {
            nodeByKeyValue.set(keyValue, node);
          }
        }
      }
  
      // Compute the key for each datum.
      // If there a node associated with this key, join and add it to update.
      // If there is not (or the key is a duplicate), add it to enter.
      for (i = 0; i < dataLength; ++i) {
        keyValue = key.call(parent, data[i], i, data) + "";
        if (node = nodeByKeyValue.get(keyValue)) {
          update[i] = node;
          node.__data__ = data[i];
          nodeByKeyValue["delete"](keyValue);
        } else {
          enter[i] = new EnterNode(parent, data[i]);
        }
      }
  
      // Add any remaining nodes that were not bound to data to exit.
      for (i = 0; i < groupLength; ++i) {
        if ((node = group[i]) && nodeByKeyValue.get(keyValues[i]) === node) {
          exit[i] = node;
        }
      }
    }
    function datum(node) {
      return node.__data__;
    }
    function selection_data (value, key) {
      if (!arguments.length) return Array.from(this, datum);
      var bind = key ? bindKey : bindIndex,
        parents = this._parents,
        groups = this._groups;
      if (typeof value !== "function") value = constant(value);
      for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
        var parent = parents[j],
          group = groups[j],
          groupLength = group.length,
          data = arraylike(value.call(parent, parent && parent.__data__, j, parents)),
          dataLength = data.length,
          enterGroup = enter[j] = new Array(dataLength),
          updateGroup = update[j] = new Array(dataLength),
          exitGroup = exit[j] = new Array(groupLength);
        bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);
  
        // Now connect the enter nodes to their following update node, such that
        // appendChild can insert the materialized enter node before this node,
        // rather than at the end of the parent node.
        for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
          if (previous = enterGroup[i0]) {
            if (i0 >= i1) i1 = i0 + 1;
            while (!(next = updateGroup[i1]) && ++i1 < dataLength) {
            }
            previous._next = next || null;
          }
        }
      }
      update = new Selection(update, parents);
      update._enter = enter;
      update._exit = exit;
      return update;
    }
  
    // Given some data, this returns an array-like view of it: an object that
    // exposes a length property and allows numeric indexing. Note that unlike
    // selectAll, this isn’t worried about “live” collections because the resulting
    // array will only be used briefly while data is being bound. (It is possible to
    // cause the data to change while iterating by using a key function, but please
    // don’t; we’d rather avoid a gratuitous copy.)
    function arraylike(data) {
      return _typeof(data) === "object" && "length" in data ? data // Array, TypedArray, NodeList, array-like
      : Array.from(data); // Map, Set, iterable, string, or anything else
    }
  
    function selection_exit () {
      return new Selection(this._exit || this._groups.map(sparse), this._parents);
    }
  
    function selection_join (onenter, onupdate, onexit) {
      var enter = this.enter(),
        update = this,
        exit = this.exit();
      if (typeof onenter === "function") {
        enter = onenter(enter);
        if (enter) enter = enter.selection();
      } else {
        enter = enter.append(onenter + "");
      }
      if (onupdate != null) {
        update = onupdate(update);
        if (update) update = update.selection();
      }
      if (onexit == null) exit.remove();else onexit(exit);
      return enter && update ? enter.merge(update).order() : update;
    }
  
    function selection_merge (context) {
      var selection = context.selection ? context.selection() : context;
      for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
        for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group0[i] || group1[i]) {
            merge[i] = node;
          }
        }
      }
      for (; j < m0; ++j) {
        merges[j] = groups0[j];
      }
      return new Selection(merges, this._parents);
    }
  
    function selection_order () {
      for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
        for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
          if (node = group[i]) {
            if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
            next = node;
          }
        }
      }
      return this;
    }
  
    function selection_sort (compare) {
      if (!compare) compare = ascending;
      function compareNode(a, b) {
        return a && b ? compare(a.__data__, b.__data__) : !a - !b;
      }
      for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            sortgroup[i] = node;
          }
        }
        sortgroup.sort(compareNode);
      }
      return new Selection(sortgroups, this._parents).order();
    }
    function ascending(a, b) {
      return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }
  
    function selection_call () {
      var callback = arguments[0];
      arguments[0] = this;
      callback.apply(null, arguments);
      return this;
    }
  
    function selection_nodes () {
      return Array.from(this);
    }
  
    function selection_node () {
      for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
          var node = group[i];
          if (node) return node;
        }
      }
      return null;
    }
  
    function selection_size () {
      var size = 0;
      var _iterator = _createForOfIteratorHelper(this),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var node = _step.value;
          ++size;
        } // eslint-disable-line no-unused-vars
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return size;
    }
  
    function selection_empty () {
      return !this.node();
    }
  
    function selection_each (callback) {
      for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
          if (node = group[i]) callback.call(node, node.__data__, i, group);
        }
      }
      return this;
    }
  
    function attrRemove(name) {
      return function () {
        this.removeAttribute(name);
      };
    }
    function attrRemoveNS(fullname) {
      return function () {
        this.removeAttributeNS(fullname.space, fullname.local);
      };
    }
    function attrConstant(name, value) {
      return function () {
        this.setAttribute(name, value);
      };
    }
    function attrConstantNS(fullname, value) {
      return function () {
        this.setAttributeNS(fullname.space, fullname.local, value);
      };
    }
    function attrFunction(name, value) {
      return function () {
        var v = value.apply(this, arguments);
        if (v == null) this.removeAttribute(name);else this.setAttribute(name, v);
      };
    }
    function attrFunctionNS(fullname, value) {
      return function () {
        var v = value.apply(this, arguments);
        if (v == null) this.removeAttributeNS(fullname.space, fullname.local);else this.setAttributeNS(fullname.space, fullname.local, v);
      };
    }
    function selection_attr (name, value) {
      var fullname = namespace(name);
      if (arguments.length < 2) {
        var node = this.node();
        return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
      }
      return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));
    }
  
    function defaultView (node) {
      return node.ownerDocument && node.ownerDocument.defaultView // node is a Node
      || node.document && node // node is a Window
      || node.defaultView; // node is a Document
    }
  
    function styleRemove(name) {
      return function () {
        this.style.removeProperty(name);
      };
    }
    function styleConstant(name, value, priority) {
      return function () {
        this.style.setProperty(name, value, priority);
      };
    }
    function styleFunction(name, value, priority) {
      return function () {
        var v = value.apply(this, arguments);
        if (v == null) this.style.removeProperty(name);else this.style.setProperty(name, v, priority);
      };
    }
    function selection_style (name, value, priority) {
      return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === "function" ? styleFunction : styleConstant)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
    }
    function styleValue(node, name) {
      return node.style.getPropertyValue(name) || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
    }
  
    function propertyRemove(name) {
      return function () {
        delete this[name];
      };
    }
    function propertyConstant(name, value) {
      return function () {
        this[name] = value;
      };
    }
    function propertyFunction(name, value) {
      return function () {
        var v = value.apply(this, arguments);
        if (v == null) delete this[name];else this[name] = v;
      };
    }
    function selection_property (name, value) {
      return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
    }
  
    function classArray(string) {
      return string.trim().split(/^|\s+/);
    }
    function classList(node) {
      return node.classList || new ClassList(node);
    }
    function ClassList(node) {
      this._node = node;
      this._names = classArray(node.getAttribute("class") || "");
    }
    ClassList.prototype = {
      add: function add(name) {
        var i = this._names.indexOf(name);
        if (i < 0) {
          this._names.push(name);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      remove: function remove(name) {
        var i = this._names.indexOf(name);
        if (i >= 0) {
          this._names.splice(i, 1);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      contains: function contains(name) {
        return this._names.indexOf(name) >= 0;
      }
    };
    function classedAdd(node, names) {
      var list = classList(node),
        i = -1,
        n = names.length;
      while (++i < n) {
        list.add(names[i]);
      }
    }
    function classedRemove(node, names) {
      var list = classList(node),
        i = -1,
        n = names.length;
      while (++i < n) {
        list.remove(names[i]);
      }
    }
    function classedTrue(names) {
      return function () {
        classedAdd(this, names);
      };
    }
    function classedFalse(names) {
      return function () {
        classedRemove(this, names);
      };
    }
    function classedFunction(names, value) {
      return function () {
        (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
      };
    }
    function selection_classed (name, value) {
      var names = classArray(name + "");
      if (arguments.length < 2) {
        var list = classList(this.node()),
          i = -1,
          n = names.length;
        while (++i < n) {
          if (!list.contains(names[i])) return false;
        }
        return true;
      }
      return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
    }
  
    function textRemove() {
      this.textContent = "";
    }
    function textConstant(value) {
      return function () {
        this.textContent = value;
      };
    }
    function textFunction(value) {
      return function () {
        var v = value.apply(this, arguments);
        this.textContent = v == null ? "" : v;
      };
    }
    function selection_text (value) {
      return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction : textConstant)(value)) : this.node().textContent;
    }
  
    function htmlRemove() {
      this.innerHTML = "";
    }
    function htmlConstant(value) {
      return function () {
        this.innerHTML = value;
      };
    }
    function htmlFunction(value) {
      return function () {
        var v = value.apply(this, arguments);
        this.innerHTML = v == null ? "" : v;
      };
    }
    function selection_html (value) {
      return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
    }
  
    function raise() {
      if (this.nextSibling) this.parentNode.appendChild(this);
    }
    function selection_raise () {
      return this.each(raise);
    }
  
    function lower() {
      if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
    }
    function selection_lower () {
      return this.each(lower);
    }
  
    function selection_append (name) {
      var create = typeof name === "function" ? name : creator(name);
      return this.select(function () {
        return this.appendChild(create.apply(this, arguments));
      });
    }
  
    function constantNull() {
      return null;
    }
    function selection_insert (name, before) {
      var create = typeof name === "function" ? name : creator(name),
        select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
      return this.select(function () {
        return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
      });
    }
  
    function remove() {
      var parent = this.parentNode;
      if (parent) parent.removeChild(this);
    }
    function selection_remove () {
      return this.each(remove);
    }
  
    function selection_cloneShallow() {
      var clone = this.cloneNode(false),
        parent = this.parentNode;
      return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
    }
    function selection_cloneDeep() {
      var clone = this.cloneNode(true),
        parent = this.parentNode;
      return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
    }
    function selection_clone (deep) {
      return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
    }
  
    function selection_datum (value) {
      return arguments.length ? this.property("__data__", value) : this.node().__data__;
    }
  
    function contextListener(listener) {
      return function (event) {
        listener.call(this, event, this.__data__);
      };
    }
    function parseTypenames(typenames) {
      return typenames.trim().split(/^|\s+/).map(function (t) {
        var name = "",
          i = t.indexOf(".");
        if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
        return {
          type: t,
          name: name
        };
      });
    }
    function onRemove(typename) {
      return function () {
        var on = this.__on;
        if (!on) return;
        for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
          if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
            this.removeEventListener(o.type, o.listener, o.options);
          } else {
            on[++i] = o;
          }
        }
        if (++i) on.length = i;else delete this.__on;
      };
    }
    function onAdd(typename, value, options) {
      return function () {
        var on = this.__on,
          o,
          listener = contextListener(value);
        if (on) for (var j = 0, m = on.length; j < m; ++j) {
          if ((o = on[j]).type === typename.type && o.name === typename.name) {
            this.removeEventListener(o.type, o.listener, o.options);
            this.addEventListener(o.type, o.listener = listener, o.options = options);
            o.value = value;
            return;
          }
        }
        this.addEventListener(typename.type, listener, options);
        o = {
          type: typename.type,
          name: typename.name,
          value: value,
          listener: listener,
          options: options
        };
        if (!on) this.__on = [o];else on.push(o);
      };
    }
    function selection_on (typename, value, options) {
      var typenames = parseTypenames(typename + ""),
        i,
        n = typenames.length,
        t;
      if (arguments.length < 2) {
        var on = this.node().__on;
        if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
          for (i = 0, o = on[j]; i < n; ++i) {
            if ((t = typenames[i]).type === o.type && t.name === o.name) {
              return o.value;
            }
          }
        }
        return;
      }
      on = value ? onAdd : onRemove;
      for (i = 0; i < n; ++i) {
        this.each(on(typenames[i], value, options));
      }
      return this;
    }
  
    function dispatchEvent(node, type, params) {
      var window = defaultView(node),
        event = window.CustomEvent;
      if (typeof event === "function") {
        event = new event(type, params);
      } else {
        event = window.document.createEvent("Event");
        if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;else event.initEvent(type, false, false);
      }
      node.dispatchEvent(event);
    }
    function dispatchConstant(type, params) {
      return function () {
        return dispatchEvent(this, type, params);
      };
    }
    function dispatchFunction(type, params) {
      return function () {
        return dispatchEvent(this, type, params.apply(this, arguments));
      };
    }
    function selection_dispatch (type, params) {
      return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type, params));
    }
  
    var _marked = /*#__PURE__*/_regeneratorRuntime().mark(_callee);
    function _callee() {
      var groups, j, m, group, i, n, node;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              groups = this._groups, j = 0, m = groups.length;
            case 1:
              if (!(j < m)) {
                _context.next = 13;
                break;
              }
              group = groups[j], i = 0, n = group.length;
            case 3:
              if (!(i < n)) {
                _context.next = 10;
                break;
              }
              if (!(node = group[i])) {
                _context.next = 7;
                break;
              }
              _context.next = 7;
              return node;
            case 7:
              ++i;
              _context.next = 3;
              break;
            case 10:
              ++j;
              _context.next = 1;
              break;
            case 13:
            case "end":
              return _context.stop();
          }
        }
      }, _marked, this);
    }
  
    var root = [null];
    function Selection(groups, parents) {
      this._groups = groups;
      this._parents = parents;
    }
    function selection() {
      return new Selection([[document.documentElement]], root);
    }
    function selection_selection() {
      return this;
    }
    Selection.prototype = selection.prototype = _defineProperty({
      constructor: Selection,
      select: selection_select,
      selectAll: selection_selectAll,
      selectChild: selection_selectChild,
      selectChildren: selection_selectChildren,
      filter: selection_filter,
      data: selection_data,
      enter: selection_enter,
      exit: selection_exit,
      join: selection_join,
      merge: selection_merge,
      selection: selection_selection,
      order: selection_order,
      sort: selection_sort,
      call: selection_call,
      nodes: selection_nodes,
      node: selection_node,
      size: selection_size,
      empty: selection_empty,
      each: selection_each,
      attr: selection_attr,
      style: selection_style,
      property: selection_property,
      classed: selection_classed,
      text: selection_text,
      html: selection_html,
      raise: selection_raise,
      lower: selection_lower,
      append: selection_append,
      insert: selection_insert,
      remove: selection_remove,
      clone: selection_clone,
      datum: selection_datum,
      on: selection_on,
      dispatch: selection_dispatch
    }, Symbol.iterator, _callee);
  
    function select (selector) {
      return typeof selector === "string" ? new Selection([[document.querySelector(selector)]], [document.documentElement]) : new Selection([[selector]], root);
    }
  
    function selectAll (selector) {
      return typeof selector === "string" ? new Selection([document.querySelectorAll(selector)], [document.documentElement]) : new Selection([array(selector)], root);
    }
  
    function ascending$1(a, b) {
      return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }
  
    function descending(a, b) {
      return a == null || b == null ? NaN : b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
    }
  
    function bisector(f) {
      var compare1, compare2, delta;
  
      // If an accessor is specified, promote it to a comparator. In this case we
      // can test whether the search value is (self-) comparable. We can’t do this
      // for a comparator (except for specific, known comparators) because we can’t
      // tell if the comparator is symmetric, and an asymmetric comparator can’t be
      // used to test whether a single value is comparable.
      if (f.length !== 2) {
        compare1 = ascending$1;
        compare2 = function compare2(d, x) {
          return ascending$1(f(d), x);
        };
        delta = function delta(d, x) {
          return f(d) - x;
        };
      } else {
        compare1 = f === ascending$1 || f === descending ? f : zero;
        compare2 = f;
        delta = f;
      }
      function left(a, x) {
        var lo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var hi = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : a.length;
        if (lo < hi) {
          if (compare1(x, x) !== 0) return hi;
          do {
            var mid = lo + hi >>> 1;
            if (compare2(a[mid], x) < 0) lo = mid + 1;else hi = mid;
          } while (lo < hi);
        }
        return lo;
      }
      function right(a, x) {
        var lo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var hi = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : a.length;
        if (lo < hi) {
          if (compare1(x, x) !== 0) return hi;
          do {
            var mid = lo + hi >>> 1;
            if (compare2(a[mid], x) <= 0) lo = mid + 1;else hi = mid;
          } while (lo < hi);
        }
        return lo;
      }
      function center(a, x) {
        var lo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var hi = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : a.length;
        var i = left(a, x, lo, hi - 1);
        return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
      }
      return {
        left: left,
        center: center,
        right: right
      };
    }
    function zero() {
      return 0;
    }
  
    function number(x) {
      return x === null ? NaN : +x;
    }
  
    var ascendingBisect = bisector(ascending$1);
    var bisectRight = ascendingBisect.right;
    var bisectCenter = bisector(number).center;
  
    function extent(values, valueof) {
      var min;
      var max;
      if (valueof === undefined) {
        var _iterator = _createForOfIteratorHelper(values),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var value = _step.value;
            if (value != null) {
              if (min === undefined) {
                if (value >= value) min = max = value;
              } else {
                if (min > value) min = value;
                if (max < value) max = value;
              }
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      } else {
        var index = -1;
        var _iterator2 = _createForOfIteratorHelper(values),
          _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var _value = _step2.value;
            if ((_value = valueof(_value, ++index, values)) != null) {
              if (min === undefined) {
                if (_value >= _value) min = max = _value;
              } else {
                if (min > _value) min = _value;
                if (max < _value) max = _value;
              }
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
      return [min, max];
    }
  
    var e10 = Math.sqrt(50),
      e5 = Math.sqrt(10),
      e2 = Math.sqrt(2);
    function tickStep(start, stop, count) {
      var step0 = Math.abs(stop - start) / Math.max(0, count),
        step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
        error = step0 / step1;
      if (error >= e10) step1 *= 10;else if (error >= e5) step1 *= 5;else if (error >= e2) step1 *= 2;
      return stop < start ? -step1 : step1;
    }
  
    function max(values, valueof) {
      var max;
      if (valueof === undefined) {
        var _iterator = _createForOfIteratorHelper(values),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var value = _step.value;
            if (value != null && (max < value || max === undefined && value >= value)) {
              max = value;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      } else {
        var index = -1;
        var _iterator2 = _createForOfIteratorHelper(values),
          _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var _value = _step2.value;
            if ((_value = valueof(_value, ++index, values)) != null && (max < _value || max === undefined && _value >= _value)) {
              max = _value;
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
      return max;
    }
  
    function initRange(domain, range) {
      switch (arguments.length) {
        case 0:
          break;
        case 1:
          this.range(domain);
          break;
        default:
          this.range(range).domain(domain);
          break;
      }
      return this;
    }
  
    function define (constructor, factory, prototype) {
      constructor.prototype = factory.prototype = prototype;
      prototype.constructor = constructor;
    }
    function extend(parent, definition) {
      var prototype = Object.create(parent.prototype);
      for (var key in definition) {
        prototype[key] = definition[key];
      }
      return prototype;
    }
  
    function Color() {}
    var _darker = 0.7;
    var _brighter = 1 / _darker;
    var reI = "\\s*([+-]?\\d+)\\s*",
      reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",
      reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
      reHex = /^#([0-9a-f]{3,8})$/,
      reRgbInteger = new RegExp("^rgb\\(".concat(reI, ",").concat(reI, ",").concat(reI, "\\)$")),
      reRgbPercent = new RegExp("^rgb\\(".concat(reP, ",").concat(reP, ",").concat(reP, "\\)$")),
      reRgbaInteger = new RegExp("^rgba\\(".concat(reI, ",").concat(reI, ",").concat(reI, ",").concat(reN, "\\)$")),
      reRgbaPercent = new RegExp("^rgba\\(".concat(reP, ",").concat(reP, ",").concat(reP, ",").concat(reN, "\\)$")),
      reHslPercent = new RegExp("^hsl\\(".concat(reN, ",").concat(reP, ",").concat(reP, "\\)$")),
      reHslaPercent = new RegExp("^hsla\\(".concat(reN, ",").concat(reP, ",").concat(reP, ",").concat(reN, "\\)$"));
    var named = {
      aliceblue: 0xf0f8ff,
      antiquewhite: 0xfaebd7,
      aqua: 0x00ffff,
      aquamarine: 0x7fffd4,
      azure: 0xf0ffff,
      beige: 0xf5f5dc,
      bisque: 0xffe4c4,
      black: 0x000000,
      blanchedalmond: 0xffebcd,
      blue: 0x0000ff,
      blueviolet: 0x8a2be2,
      brown: 0xa52a2a,
      burlywood: 0xdeb887,
      cadetblue: 0x5f9ea0,
      chartreuse: 0x7fff00,
      chocolate: 0xd2691e,
      coral: 0xff7f50,
      cornflowerblue: 0x6495ed,
      cornsilk: 0xfff8dc,
      crimson: 0xdc143c,
      cyan: 0x00ffff,
      darkblue: 0x00008b,
      darkcyan: 0x008b8b,
      darkgoldenrod: 0xb8860b,
      darkgray: 0xa9a9a9,
      darkgreen: 0x006400,
      darkgrey: 0xa9a9a9,
      darkkhaki: 0xbdb76b,
      darkmagenta: 0x8b008b,
      darkolivegreen: 0x556b2f,
      darkorange: 0xff8c00,
      darkorchid: 0x9932cc,
      darkred: 0x8b0000,
      darksalmon: 0xe9967a,
      darkseagreen: 0x8fbc8f,
      darkslateblue: 0x483d8b,
      darkslategray: 0x2f4f4f,
      darkslategrey: 0x2f4f4f,
      darkturquoise: 0x00ced1,
      darkviolet: 0x9400d3,
      deeppink: 0xff1493,
      deepskyblue: 0x00bfff,
      dimgray: 0x696969,
      dimgrey: 0x696969,
      dodgerblue: 0x1e90ff,
      firebrick: 0xb22222,
      floralwhite: 0xfffaf0,
      forestgreen: 0x228b22,
      fuchsia: 0xff00ff,
      gainsboro: 0xdcdcdc,
      ghostwhite: 0xf8f8ff,
      gold: 0xffd700,
      goldenrod: 0xdaa520,
      gray: 0x808080,
      green: 0x008000,
      greenyellow: 0xadff2f,
      grey: 0x808080,
      honeydew: 0xf0fff0,
      hotpink: 0xff69b4,
      indianred: 0xcd5c5c,
      indigo: 0x4b0082,
      ivory: 0xfffff0,
      khaki: 0xf0e68c,
      lavender: 0xe6e6fa,
      lavenderblush: 0xfff0f5,
      lawngreen: 0x7cfc00,
      lemonchiffon: 0xfffacd,
      lightblue: 0xadd8e6,
      lightcoral: 0xf08080,
      lightcyan: 0xe0ffff,
      lightgoldenrodyellow: 0xfafad2,
      lightgray: 0xd3d3d3,
      lightgreen: 0x90ee90,
      lightgrey: 0xd3d3d3,
      lightpink: 0xffb6c1,
      lightsalmon: 0xffa07a,
      lightseagreen: 0x20b2aa,
      lightskyblue: 0x87cefa,
      lightslategray: 0x778899,
      lightslategrey: 0x778899,
      lightsteelblue: 0xb0c4de,
      lightyellow: 0xffffe0,
      lime: 0x00ff00,
      limegreen: 0x32cd32,
      linen: 0xfaf0e6,
      magenta: 0xff00ff,
      maroon: 0x800000,
      mediumaquamarine: 0x66cdaa,
      mediumblue: 0x0000cd,
      mediumorchid: 0xba55d3,
      mediumpurple: 0x9370db,
      mediumseagreen: 0x3cb371,
      mediumslateblue: 0x7b68ee,
      mediumspringgreen: 0x00fa9a,
      mediumturquoise: 0x48d1cc,
      mediumvioletred: 0xc71585,
      midnightblue: 0x191970,
      mintcream: 0xf5fffa,
      mistyrose: 0xffe4e1,
      moccasin: 0xffe4b5,
      navajowhite: 0xffdead,
      navy: 0x000080,
      oldlace: 0xfdf5e6,
      olive: 0x808000,
      olivedrab: 0x6b8e23,
      orange: 0xffa500,
      orangered: 0xff4500,
      orchid: 0xda70d6,
      palegoldenrod: 0xeee8aa,
      palegreen: 0x98fb98,
      paleturquoise: 0xafeeee,
      palevioletred: 0xdb7093,
      papayawhip: 0xffefd5,
      peachpuff: 0xffdab9,
      peru: 0xcd853f,
      pink: 0xffc0cb,
      plum: 0xdda0dd,
      powderblue: 0xb0e0e6,
      purple: 0x800080,
      rebeccapurple: 0x663399,
      red: 0xff0000,
      rosybrown: 0xbc8f8f,
      royalblue: 0x4169e1,
      saddlebrown: 0x8b4513,
      salmon: 0xfa8072,
      sandybrown: 0xf4a460,
      seagreen: 0x2e8b57,
      seashell: 0xfff5ee,
      sienna: 0xa0522d,
      silver: 0xc0c0c0,
      skyblue: 0x87ceeb,
      slateblue: 0x6a5acd,
      slategray: 0x708090,
      slategrey: 0x708090,
      snow: 0xfffafa,
      springgreen: 0x00ff7f,
      steelblue: 0x4682b4,
      tan: 0xd2b48c,
      teal: 0x008080,
      thistle: 0xd8bfd8,
      tomato: 0xff6347,
      turquoise: 0x40e0d0,
      violet: 0xee82ee,
      wheat: 0xf5deb3,
      white: 0xffffff,
      whitesmoke: 0xf5f5f5,
      yellow: 0xffff00,
      yellowgreen: 0x9acd32
    };
    define(Color, color, {
      copy: function copy(channels) {
        return Object.assign(new this.constructor(), this, channels);
      },
      displayable: function displayable() {
        return this.rgb().displayable();
      },
      hex: color_formatHex,
      // Deprecated! Use color.formatHex.
      formatHex: color_formatHex,
      formatHex8: color_formatHex8,
      formatHsl: color_formatHsl,
      formatRgb: color_formatRgb,
      toString: color_formatRgb
    });
    function color_formatHex() {
      return this.rgb().formatHex();
    }
    function color_formatHex8() {
      return this.rgb().formatHex8();
    }
    function color_formatHsl() {
      return hslConvert(this).formatHsl();
    }
    function color_formatRgb() {
      return this.rgb().formatRgb();
    }
    function color(format) {
      var m, l;
      format = (format + "").trim().toLowerCase();
      return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
      : l === 3 ? new Rgb(m >> 8 & 0xf | m >> 4 & 0xf0, m >> 4 & 0xf | m & 0xf0, (m & 0xf) << 4 | m & 0xf, 1) // #f00
      : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
      : l === 4 ? rgba(m >> 12 & 0xf | m >> 8 & 0xf0, m >> 8 & 0xf | m >> 4 & 0xf0, m >> 4 & 0xf | m & 0xf0, ((m & 0xf) << 4 | m & 0xf) / 0xff) // #f000
      : null // invalid hex
      ) : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
    }
    function rgbn(n) {
      return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
    }
    function rgba(r, g, b, a) {
      if (a <= 0) r = g = b = NaN;
      return new Rgb(r, g, b, a);
    }
    function rgbConvert(o) {
      if (!(o instanceof Color)) o = color(o);
      if (!o) return new Rgb();
      o = o.rgb();
      return new Rgb(o.r, o.g, o.b, o.opacity);
    }
    function rgb(r, g, b, opacity) {
      return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
    }
    function Rgb(r, g, b, opacity) {
      this.r = +r;
      this.g = +g;
      this.b = +b;
      this.opacity = +opacity;
    }
    define(Rgb, rgb, extend(Color, {
      brighter: function brighter(k) {
        k = k == null ? _brighter : Math.pow(_brighter, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
      },
      darker: function darker(k) {
        k = k == null ? _darker : Math.pow(_darker, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
      },
      rgb: function rgb() {
        return this;
      },
      clamp: function clamp() {
        return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
      },
      displayable: function displayable() {
        return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
      },
      hex: rgb_formatHex,
      // Deprecated! Use color.formatHex.
      formatHex: rgb_formatHex,
      formatHex8: rgb_formatHex8,
      formatRgb: rgb_formatRgb,
      toString: rgb_formatRgb
    }));
    function rgb_formatHex() {
      return "#".concat(hex(this.r)).concat(hex(this.g)).concat(hex(this.b));
    }
    function rgb_formatHex8() {
      return "#".concat(hex(this.r)).concat(hex(this.g)).concat(hex(this.b)).concat(hex((isNaN(this.opacity) ? 1 : this.opacity) * 255));
    }
    function rgb_formatRgb() {
      var a = clampa(this.opacity);
      return "".concat(a === 1 ? "rgb(" : "rgba(").concat(clampi(this.r), ", ").concat(clampi(this.g), ", ").concat(clampi(this.b)).concat(a === 1 ? ")" : ", ".concat(a, ")"));
    }
    function clampa(opacity) {
      return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
    }
    function clampi(value) {
      return Math.max(0, Math.min(255, Math.round(value) || 0));
    }
    function hex(value) {
      value = clampi(value);
      return (value < 16 ? "0" : "") + value.toString(16);
    }
    function hsla(h, s, l, a) {
      if (a <= 0) h = s = l = NaN;else if (l <= 0 || l >= 1) h = s = NaN;else if (s <= 0) h = NaN;
      return new Hsl(h, s, l, a);
    }
    function hslConvert(o) {
      if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
      if (!(o instanceof Color)) o = color(o);
      if (!o) return new Hsl();
      if (o instanceof Hsl) return o;
      o = o.rgb();
      var r = o.r / 255,
        g = o.g / 255,
        b = o.b / 255,
        min = Math.min(r, g, b),
        max = Math.max(r, g, b),
        h = NaN,
        s = max - min,
        l = (max + min) / 2;
      if (s) {
        if (r === max) h = (g - b) / s + (g < b) * 6;else if (g === max) h = (b - r) / s + 2;else h = (r - g) / s + 4;
        s /= l < 0.5 ? max + min : 2 - max - min;
        h *= 60;
      } else {
        s = l > 0 && l < 1 ? 0 : h;
      }
      return new Hsl(h, s, l, o.opacity);
    }
    function hsl(h, s, l, opacity) {
      return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
    }
    function Hsl(h, s, l, opacity) {
      this.h = +h;
      this.s = +s;
      this.l = +l;
      this.opacity = +opacity;
    }
    define(Hsl, hsl, extend(Color, {
      brighter: function brighter(k) {
        k = k == null ? _brighter : Math.pow(_brighter, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
      },
      darker: function darker(k) {
        k = k == null ? _darker : Math.pow(_darker, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
      },
      rgb: function rgb() {
        var h = this.h % 360 + (this.h < 0) * 360,
          s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
          l = this.l,
          m2 = l + (l < 0.5 ? l : 1 - l) * s,
          m1 = 2 * l - m2;
        return new Rgb(hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2), hsl2rgb(h, m1, m2), hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2), this.opacity);
      },
      clamp: function clamp() {
        return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
      },
      displayable: function displayable() {
        return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
      },
      formatHsl: function formatHsl() {
        var a = clampa(this.opacity);
        return "".concat(a === 1 ? "hsl(" : "hsla(").concat(clamph(this.h), ", ").concat(clampt(this.s) * 100, "%, ").concat(clampt(this.l) * 100, "%").concat(a === 1 ? ")" : ", ".concat(a, ")"));
      }
    }));
    function clamph(value) {
      value = (value || 0) % 360;
      return value < 0 ? value + 360 : value;
    }
    function clampt(value) {
      return Math.max(0, Math.min(1, value || 0));
    }
  
    /* From FvD 13.37, CSS Color Module Level 3 */
    function hsl2rgb(h, m1, m2) {
      return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
    }
  
    var constant$1 = (function (x) {
      return function () {
        return x;
      };
    });
  
    function linear(a, d) {
      return function (t) {
        return a + t * d;
      };
    }
    function exponential(a, b, y) {
      return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function (t) {
        return Math.pow(a + t * b, y);
      };
    }
    function gamma(y) {
      return (y = +y) === 1 ? nogamma : function (a, b) {
        return b - a ? exponential(a, b, y) : constant$1(isNaN(a) ? b : a);
      };
    }
    function nogamma(a, b) {
      var d = b - a;
      return d ? linear(a, d) : constant$1(isNaN(a) ? b : a);
    }
  
    var rgb$1 = (function rgbGamma(y) {
      var color = gamma(y);
      function rgb$1(start, end) {
        var r = color((start = rgb(start)).r, (end = rgb(end)).r),
          g = color(start.g, end.g),
          b = color(start.b, end.b),
          opacity = nogamma(start.opacity, end.opacity);
        return function (t) {
          start.r = r(t);
          start.g = g(t);
          start.b = b(t);
          start.opacity = opacity(t);
          return start + "";
        };
      }
      rgb$1.gamma = rgbGamma;
      return rgb$1;
    })(1);
  
    function numberArray (a, b) {
      if (!b) b = [];
      var n = a ? Math.min(b.length, a.length) : 0,
        c = b.slice(),
        i;
      return function (t) {
        for (i = 0; i < n; ++i) {
          c[i] = a[i] * (1 - t) + b[i] * t;
        }
        return c;
      };
    }
    function isNumberArray(x) {
      return ArrayBuffer.isView(x) && !(x instanceof DataView);
    }
  
    function genericArray(a, b) {
      var nb = b ? b.length : 0,
        na = a ? Math.min(nb, a.length) : 0,
        x = new Array(na),
        c = new Array(nb),
        i;
      for (i = 0; i < na; ++i) {
        x[i] = interpolate(a[i], b[i]);
      }
      for (; i < nb; ++i) {
        c[i] = b[i];
      }
      return function (t) {
        for (i = 0; i < na; ++i) {
          c[i] = x[i](t);
        }
        return c;
      };
    }
  
    function date (a, b) {
      var d = new Date();
      return a = +a, b = +b, function (t) {
        return d.setTime(a * (1 - t) + b * t), d;
      };
    }
  
    function interpolateNumber (a, b) {
      return a = +a, b = +b, function (t) {
        return a * (1 - t) + b * t;
      };
    }
  
    function object (a, b) {
      var i = {},
        c = {},
        k;
      if (a === null || _typeof(a) !== "object") a = {};
      if (b === null || _typeof(b) !== "object") b = {};
      for (k in b) {
        if (k in a) {
          i[k] = interpolate(a[k], b[k]);
        } else {
          c[k] = b[k];
        }
      }
      return function (t) {
        for (k in i) {
          c[k] = i[k](t);
        }
        return c;
      };
    }
  
    var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
      reB = new RegExp(reA.source, "g");
    function zero$1(b) {
      return function () {
        return b;
      };
    }
    function one(b) {
      return function (t) {
        return b(t) + "";
      };
    }
    function string (a, b) {
      var bi = reA.lastIndex = reB.lastIndex = 0,
        // scan index for next number in b
        am,
        // current match in a
        bm,
        // current match in b
        bs,
        // string preceding current number in b, if any
        i = -1,
        // index in s
        s = [],
        // string constants and placeholders
        q = []; // number interpolators
  
      // Coerce inputs to strings.
      a = a + "", b = b + "";
  
      // Interpolate pairs of numbers in a & b.
      while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
        if ((bs = bm.index) > bi) {
          // a string precedes the next number in b
          bs = b.slice(bi, bs);
          if (s[i]) s[i] += bs; // coalesce with previous string
          else s[++i] = bs;
        }
        if ((am = am[0]) === (bm = bm[0])) {
          // numbers in a & b match
          if (s[i]) s[i] += bm; // coalesce with previous string
          else s[++i] = bm;
        } else {
          // interpolate non-matching numbers
          s[++i] = null;
          q.push({
            i: i,
            x: interpolateNumber(am, bm)
          });
        }
        bi = reB.lastIndex;
      }
  
      // Add remains of b.
      if (bi < b.length) {
        bs = b.slice(bi);
        if (s[i]) s[i] += bs; // coalesce with previous string
        else s[++i] = bs;
      }
  
      // Special optimization for only a single match.
      // Otherwise, interpolate each of the numbers and rejoin the string.
      return s.length < 2 ? q[0] ? one(q[0].x) : zero$1(b) : (b = q.length, function (t) {
        for (var i = 0, o; i < b; ++i) {
          s[(o = q[i]).i] = o.x(t);
        }
        return s.join("");
      });
    }
  
    function interpolate (a, b) {
      var t = _typeof(b),
        c;
      return b == null || t === "boolean" ? constant$1(b) : (t === "number" ? interpolateNumber : t === "string" ? (c = color(b)) ? (b = c, rgb$1) : string : b instanceof color ? rgb$1 : b instanceof Date ? date : isNumberArray(b) ? numberArray : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object : interpolateNumber)(a, b);
    }
  
    function interpolateRound (a, b) {
      return a = +a, b = +b, function (t) {
        return Math.round(a * (1 - t) + b * t);
      };
    }
  
    function constants(x) {
      return function () {
        return x;
      };
    }
  
    function number$1(x) {
      return +x;
    }
  
    var unit = [0, 1];
    function identity(x) {
      return x;
    }
    function normalize(a, b) {
      return (b -= a = +a) ? function (x) {
        return (x - a) / b;
      } : constants(isNaN(b) ? NaN : 0.5);
    }
    function clamper(a, b) {
      var t;
      if (a > b) t = a, a = b, b = t;
      return function (x) {
        return Math.max(a, Math.min(b, x));
      };
    }
  
    // normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
    // interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
    function bimap(domain, range, interpolate) {
      var d0 = domain[0],
        d1 = domain[1],
        r0 = range[0],
        r1 = range[1];
      if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
      return function (x) {
        return r0(d0(x));
      };
    }
    function polymap(domain, range, interpolate) {
      var j = Math.min(domain.length, range.length) - 1,
        d = new Array(j),
        r = new Array(j),
        i = -1;
  
      // Reverse descending domains.
      if (domain[j] < domain[0]) {
        domain = domain.slice().reverse();
        range = range.slice().reverse();
      }
      while (++i < j) {
        d[i] = normalize(domain[i], domain[i + 1]);
        r[i] = interpolate(range[i], range[i + 1]);
      }
      return function (x) {
        var i = bisectRight(domain, x, 1, j) - 1;
        return r[i](d[i](x));
      };
    }
    function copy(source, target) {
      return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
    }
    function transformer() {
      var domain = unit,
        range = unit,
        interpolate$1 = interpolate,
        transform,
        untransform,
        unknown,
        clamp = identity,
        piecewise,
        output,
        input;
      function rescale() {
        var n = Math.min(domain.length, range.length);
        if (clamp !== identity) clamp = clamper(domain[0], domain[n - 1]);
        piecewise = n > 2 ? polymap : bimap;
        output = input = null;
        return scale;
      }
      function scale(x) {
        return x == null || isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate$1)))(transform(clamp(x)));
      }
      scale.invert = function (y) {
        return clamp(untransform((input || (input = piecewise(range, domain.map(transform), interpolateNumber)))(y)));
      };
      scale.domain = function (_) {
        return arguments.length ? (domain = Array.from(_, number$1), rescale()) : domain.slice();
      };
      scale.range = function (_) {
        return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
      };
      scale.rangeRound = function (_) {
        return range = Array.from(_), interpolate$1 = interpolateRound, rescale();
      };
      scale.clamp = function (_) {
        return arguments.length ? (clamp = _ ? true : identity, rescale()) : clamp !== identity;
      };
      scale.interpolate = function (_) {
        return arguments.length ? (interpolate$1 = _, rescale()) : interpolate$1;
      };
      scale.unknown = function (_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };
      return function (t, u) {
        transform = t, untransform = u;
        return rescale();
      };
    }
    function continuous() {
      return transformer()(identity, identity);
    }
  
    function nice(domain, interval) {
      domain = domain.slice();
      var i0 = 0,
        i1 = domain.length - 1,
        x0 = domain[i0],
        x1 = domain[i1],
        t;
      if (x1 < x0) {
        t = i0, i0 = i1, i1 = t;
        t = x0, x0 = x1, x1 = t;
      }
      domain[i0] = interval.floor(x0);
      domain[i1] = interval.ceil(x1);
      return domain;
    }
  
    var t0 = new Date(),
      t1 = new Date();
    function newInterval(floori, offseti, count, field) {
      function interval(date) {
        return floori(date = arguments.length === 0 ? new Date() : new Date(+date)), date;
      }
      interval.floor = function (date) {
        return floori(date = new Date(+date)), date;
      };
      interval.ceil = function (date) {
        return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
      };
      interval.round = function (date) {
        var d0 = interval(date),
          d1 = interval.ceil(date);
        return date - d0 < d1 - date ? d0 : d1;
      };
      interval.offset = function (date, step) {
        return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
      };
      interval.range = function (start, stop, step) {
        var range = [],
          previous;
        start = interval.ceil(start);
        step = step == null ? 1 : Math.floor(step);
        if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
        do {
          range.push(previous = new Date(+start)), offseti(start, step), floori(start);
        } while (previous < start && start < stop);
        return range;
      };
      interval.filter = function (test) {
        return newInterval(function (date) {
          if (date >= date) while (floori(date), !test(date)) {
            date.setTime(date - 1);
          }
        }, function (date, step) {
          if (date >= date) {
            if (step < 0) while (++step <= 0) {
              while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
            } else while (--step >= 0) {
              while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
            }
          }
        });
      };
  
      if (count) {
        interval.count = function (start, end) {
          t0.setTime(+start), t1.setTime(+end);
          floori(t0), floori(t1);
          return Math.floor(count(t0, t1));
        };
        interval.every = function (step) {
          step = Math.floor(step);
          return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval : interval.filter(field ? function (d) {
            return field(d) % step === 0;
          } : function (d) {
            return interval.count(0, d) % step === 0;
          });
        };
      }
      return interval;
    }
  
    var millisecond = newInterval(function () {
      // noop
    }, function (date, step) {
      date.setTime(+date + step);
    }, function (start, end) {
      return end - start;
    });
  
    // An optimized implementation for this simple case.
    millisecond.every = function (k) {
      k = Math.floor(k);
      if (!isFinite(k) || !(k > 0)) return null;
      if (!(k > 1)) return millisecond;
      return newInterval(function (date) {
        date.setTime(Math.floor(date / k) * k);
      }, function (date, step) {
        date.setTime(+date + step * k);
      }, function (start, end) {
        return (end - start) / k;
      });
    };
  
    var durationSecond = 1000;
    var durationMinute = durationSecond * 60;
    var durationHour = durationMinute * 60;
    var durationDay = durationHour * 24;
    var durationWeek = durationDay * 7;
    var durationMonth = durationDay * 30;
    var durationYear = durationDay * 365;
  
    var second = newInterval(function (date) {
      date.setTime(date - date.getMilliseconds());
    }, function (date, step) {
      date.setTime(+date + step * durationSecond);
    }, function (start, end) {
      return (end - start) / durationSecond;
    }, function (date) {
      return date.getUTCSeconds();
    });
  
    var minute = newInterval(function (date) {
      date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);
    }, function (date, step) {
      date.setTime(+date + step * durationMinute);
    }, function (start, end) {
      return (end - start) / durationMinute;
    }, function (date) {
      return date.getMinutes();
    });
  
    var hour = newInterval(function (date) {
      date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);
    }, function (date, step) {
      date.setTime(+date + step * durationHour);
    }, function (start, end) {
      return (end - start) / durationHour;
    }, function (date) {
      return date.getHours();
    });
  
    var day = newInterval(function (date) {
      return date.setHours(0, 0, 0, 0);
    }, function (date, step) {
      return date.setDate(date.getDate() + step);
    }, function (start, end) {
      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay;
    }, function (date) {
      return date.getDate() - 1;
    });
  
    function weekday(i) {
      return newInterval(function (date) {
        date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
        date.setHours(0, 0, 0, 0);
      }, function (date, step) {
        date.setDate(date.getDate() + step * 7);
      }, function (start, end) {
        return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
      });
    }
    var sunday = weekday(0);
    var monday = weekday(1);
    var tuesday = weekday(2);
    var wednesday = weekday(3);
    var thursday = weekday(4);
    var friday = weekday(5);
    var saturday = weekday(6);
  
    var month = newInterval(function (date) {
      date.setDate(1);
      date.setHours(0, 0, 0, 0);
    }, function (date, step) {
      date.setMonth(date.getMonth() + step);
    }, function (start, end) {
      return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
    }, function (date) {
      return date.getMonth();
    });
  
    var year = newInterval(function (date) {
      date.setMonth(0, 1);
      date.setHours(0, 0, 0, 0);
    }, function (date, step) {
      date.setFullYear(date.getFullYear() + step);
    }, function (start, end) {
      return end.getFullYear() - start.getFullYear();
    }, function (date) {
      return date.getFullYear();
    });
  
    // An optimized implementation for this simple case.
    year.every = function (k) {
      return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function (date) {
        date.setFullYear(Math.floor(date.getFullYear() / k) * k);
        date.setMonth(0, 1);
        date.setHours(0, 0, 0, 0);
      }, function (date, step) {
        date.setFullYear(date.getFullYear() + step * k);
      });
    };
  
    var utcMinute = newInterval(function (date) {
      date.setUTCSeconds(0, 0);
    }, function (date, step) {
      date.setTime(+date + step * durationMinute);
    }, function (start, end) {
      return (end - start) / durationMinute;
    }, function (date) {
      return date.getUTCMinutes();
    });
  
    var utcHour = newInterval(function (date) {
      date.setUTCMinutes(0, 0, 0);
    }, function (date, step) {
      date.setTime(+date + step * durationHour);
    }, function (start, end) {
      return (end - start) / durationHour;
    }, function (date) {
      return date.getUTCHours();
    });
  
    var utcDay = newInterval(function (date) {
      date.setUTCHours(0, 0, 0, 0);
    }, function (date, step) {
      date.setUTCDate(date.getUTCDate() + step);
    }, function (start, end) {
      return (end - start) / durationDay;
    }, function (date) {
      return date.getUTCDate() - 1;
    });
  
    function utcWeekday(i) {
      return newInterval(function (date) {
        date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
        date.setUTCHours(0, 0, 0, 0);
      }, function (date, step) {
        date.setUTCDate(date.getUTCDate() + step * 7);
      }, function (start, end) {
        return (end - start) / durationWeek;
      });
    }
    var utcSunday = utcWeekday(0);
    var utcMonday = utcWeekday(1);
    var utcTuesday = utcWeekday(2);
    var utcWednesday = utcWeekday(3);
    var utcThursday = utcWeekday(4);
    var utcFriday = utcWeekday(5);
    var utcSaturday = utcWeekday(6);
  
    var utcMonth = newInterval(function (date) {
      date.setUTCDate(1);
      date.setUTCHours(0, 0, 0, 0);
    }, function (date, step) {
      date.setUTCMonth(date.getUTCMonth() + step);
    }, function (start, end) {
      return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
    }, function (date) {
      return date.getUTCMonth();
    });
  
    var utcYear = newInterval(function (date) {
      date.setUTCMonth(0, 1);
      date.setUTCHours(0, 0, 0, 0);
    }, function (date, step) {
      date.setUTCFullYear(date.getUTCFullYear() + step);
    }, function (start, end) {
      return end.getUTCFullYear() - start.getUTCFullYear();
    }, function (date) {
      return date.getUTCFullYear();
    });
  
    // An optimized implementation for this simple case.
    utcYear.every = function (k) {
      return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function (date) {
        date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
        date.setUTCMonth(0, 1);
        date.setUTCHours(0, 0, 0, 0);
      }, function (date, step) {
        date.setUTCFullYear(date.getUTCFullYear() + step * k);
      });
    };
  
    function ticker(year, month, week, day, hour, minute) {
      var tickIntervals = [[second, 1, durationSecond], [second, 5, 5 * durationSecond], [second, 15, 15 * durationSecond], [second, 30, 30 * durationSecond], [minute, 1, durationMinute], [minute, 5, 5 * durationMinute], [minute, 15, 15 * durationMinute], [minute, 30, 30 * durationMinute], [hour, 1, durationHour], [hour, 3, 3 * durationHour], [hour, 6, 6 * durationHour], [hour, 12, 12 * durationHour], [day, 1, durationDay], [day, 2, 2 * durationDay], [week, 1, durationWeek], [month, 1, durationMonth], [month, 3, 3 * durationMonth], [year, 1, durationYear]];
      function ticks(start, stop, count) {
        var reverse = stop < start;
        if (reverse) {
          var _ref = [stop, start];
          start = _ref[0];
          stop = _ref[1];
        }
        var interval = count && typeof count.range === "function" ? count : tickInterval(start, stop, count);
        var ticks = interval ? interval.range(start, +stop + 1) : []; // inclusive stop
        return reverse ? ticks.reverse() : ticks;
      }
      function tickInterval(start, stop, count) {
        var target = Math.abs(stop - start) / count;
        var i = bisector(function (_ref2) {
          var _ref3 = _slicedToArray(_ref2, 3),
            step = _ref3[2];
          return step;
        }).right(tickIntervals, target);
        if (i === tickIntervals.length) return year.every(tickStep(start / durationYear, stop / durationYear, count));
        if (i === 0) return millisecond.every(Math.max(tickStep(start, stop, count), 1));
        var _tickIntervals = _slicedToArray(tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i], 2),
          t = _tickIntervals[0],
          step = _tickIntervals[1];
        return t.every(step);
      }
      return [ticks, tickInterval];
    }
    var _ticker = ticker(utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute),
      _ticker2 = _slicedToArray(_ticker, 2),
      utcTicks = _ticker2[0],
      utcTickInterval = _ticker2[1];
    var _ticker3 = ticker(year, month, sunday, day, hour, minute),
      _ticker4 = _slicedToArray(_ticker3, 2),
      timeTicks = _ticker4[0],
      timeTickInterval = _ticker4[1];
  
    function localDate(d) {
      if (0 <= d.y && d.y < 100) {
        var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
        date.setFullYear(d.y);
        return date;
      }
      return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
    }
    function utcDate(d) {
      if (0 <= d.y && d.y < 100) {
        var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
        date.setUTCFullYear(d.y);
        return date;
      }
      return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
    }
    function newDate(y, m, d) {
      return {
        y: y,
        m: m,
        d: d,
        H: 0,
        M: 0,
        S: 0,
        L: 0
      };
    }
    function formatLocale(locale) {
      var locale_dateTime = locale.dateTime,
        locale_date = locale.date,
        locale_time = locale.time,
        locale_periods = locale.periods,
        locale_weekdays = locale.days,
        locale_shortWeekdays = locale.shortDays,
        locale_months = locale.months,
        locale_shortMonths = locale.shortMonths;
      var periodRe = formatRe(locale_periods),
        periodLookup = formatLookup(locale_periods),
        weekdayRe = formatRe(locale_weekdays),
        weekdayLookup = formatLookup(locale_weekdays),
        shortWeekdayRe = formatRe(locale_shortWeekdays),
        shortWeekdayLookup = formatLookup(locale_shortWeekdays),
        monthRe = formatRe(locale_months),
        monthLookup = formatLookup(locale_months),
        shortMonthRe = formatRe(locale_shortMonths),
        shortMonthLookup = formatLookup(locale_shortMonths);
      var formats = {
        "a": formatShortWeekday,
        "A": formatWeekday,
        "b": formatShortMonth,
        "B": formatMonth,
        "c": null,
        "d": formatDayOfMonth,
        "e": formatDayOfMonth,
        "f": formatMicroseconds,
        "g": formatYearISO,
        "G": formatFullYearISO,
        "H": formatHour24,
        "I": formatHour12,
        "j": formatDayOfYear,
        "L": formatMilliseconds,
        "m": formatMonthNumber,
        "M": formatMinutes,
        "p": formatPeriod,
        "q": formatQuarter,
        "Q": formatUnixTimestamp,
        "s": formatUnixTimestampSeconds,
        "S": formatSeconds,
        "u": formatWeekdayNumberMonday,
        "U": formatWeekNumberSunday,
        "V": formatWeekNumberISO,
        "w": formatWeekdayNumberSunday,
        "W": formatWeekNumberMonday,
        "x": null,
        "X": null,
        "y": formatYear,
        "Y": formatFullYear,
        "Z": formatZone,
        "%": formatLiteralPercent
      };
      var utcFormats = {
        "a": formatUTCShortWeekday,
        "A": formatUTCWeekday,
        "b": formatUTCShortMonth,
        "B": formatUTCMonth,
        "c": null,
        "d": formatUTCDayOfMonth,
        "e": formatUTCDayOfMonth,
        "f": formatUTCMicroseconds,
        "g": formatUTCYearISO,
        "G": formatUTCFullYearISO,
        "H": formatUTCHour24,
        "I": formatUTCHour12,
        "j": formatUTCDayOfYear,
        "L": formatUTCMilliseconds,
        "m": formatUTCMonthNumber,
        "M": formatUTCMinutes,
        "p": formatUTCPeriod,
        "q": formatUTCQuarter,
        "Q": formatUnixTimestamp,
        "s": formatUnixTimestampSeconds,
        "S": formatUTCSeconds,
        "u": formatUTCWeekdayNumberMonday,
        "U": formatUTCWeekNumberSunday,
        "V": formatUTCWeekNumberISO,
        "w": formatUTCWeekdayNumberSunday,
        "W": formatUTCWeekNumberMonday,
        "x": null,
        "X": null,
        "y": formatUTCYear,
        "Y": formatUTCFullYear,
        "Z": formatUTCZone,
        "%": formatLiteralPercent
      };
      var parses = {
        "a": parseShortWeekday,
        "A": parseWeekday,
        "b": parseShortMonth,
        "B": parseMonth,
        "c": parseLocaleDateTime,
        "d": parseDayOfMonth,
        "e": parseDayOfMonth,
        "f": parseMicroseconds,
        "g": parseYear,
        "G": parseFullYear,
        "H": parseHour24,
        "I": parseHour24,
        "j": parseDayOfYear,
        "L": parseMilliseconds,
        "m": parseMonthNumber,
        "M": parseMinutes,
        "p": parsePeriod,
        "q": parseQuarter,
        "Q": parseUnixTimestamp,
        "s": parseUnixTimestampSeconds,
        "S": parseSeconds,
        "u": parseWeekdayNumberMonday,
        "U": parseWeekNumberSunday,
        "V": parseWeekNumberISO,
        "w": parseWeekdayNumberSunday,
        "W": parseWeekNumberMonday,
        "x": parseLocaleDate,
        "X": parseLocaleTime,
        "y": parseYear,
        "Y": parseFullYear,
        "Z": parseZone,
        "%": parseLiteralPercent
      };
  
      // These recursive directive definitions must be deferred.
      formats.x = newFormat(locale_date, formats);
      formats.X = newFormat(locale_time, formats);
      formats.c = newFormat(locale_dateTime, formats);
      utcFormats.x = newFormat(locale_date, utcFormats);
      utcFormats.X = newFormat(locale_time, utcFormats);
      utcFormats.c = newFormat(locale_dateTime, utcFormats);
      function newFormat(specifier, formats) {
        return function (date) {
          var string = [],
            i = -1,
            j = 0,
            n = specifier.length,
            c,
            pad,
            format;
          if (!(date instanceof Date)) date = new Date(+date);
          while (++i < n) {
            if (specifier.charCodeAt(i) === 37) {
              string.push(specifier.slice(j, i));
              if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);else pad = c === "e" ? " " : "0";
              if (format = formats[c]) c = format(date, pad);
              string.push(c);
              j = i + 1;
            }
          }
          string.push(specifier.slice(j, i));
          return string.join("");
        };
      }
      function newParse(specifier, Z) {
        return function (string) {
          var d = newDate(1900, undefined, 1),
            i = parseSpecifier(d, specifier, string += "", 0),
            week,
            day$1;
          if (i != string.length) return null;
  
          // If a UNIX timestamp is specified, return it.
          if ("Q" in d) return new Date(d.Q);
          if ("s" in d) return new Date(d.s * 1000 + ("L" in d ? d.L : 0));
  
          // If this is utcParse, never use the local timezone.
          if (Z && !("Z" in d)) d.Z = 0;
  
          // The am-pm flag is 0 for AM, and 1 for PM.
          if ("p" in d) d.H = d.H % 12 + d.p * 12;
  
          // If the month was not specified, inherit from the quarter.
          if (d.m === undefined) d.m = "q" in d ? d.q : 0;
  
          // Convert day-of-week and week-of-year to day-of-year.
          if ("V" in d) {
            if (d.V < 1 || d.V > 53) return null;
            if (!("w" in d)) d.w = 1;
            if ("Z" in d) {
              week = utcDate(newDate(d.y, 0, 1)), day$1 = week.getUTCDay();
              week = day$1 > 4 || day$1 === 0 ? utcMonday.ceil(week) : utcMonday(week);
              week = utcDay.offset(week, (d.V - 1) * 7);
              d.y = week.getUTCFullYear();
              d.m = week.getUTCMonth();
              d.d = week.getUTCDate() + (d.w + 6) % 7;
            } else {
              week = localDate(newDate(d.y, 0, 1)), day$1 = week.getDay();
              week = day$1 > 4 || day$1 === 0 ? monday.ceil(week) : monday(week);
              week = day.offset(week, (d.V - 1) * 7);
              d.y = week.getFullYear();
              d.m = week.getMonth();
              d.d = week.getDate() + (d.w + 6) % 7;
            }
          } else if ("W" in d || "U" in d) {
            if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
            day$1 = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
            d.m = 0;
            d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day$1 + 5) % 7 : d.w + d.U * 7 - (day$1 + 6) % 7;
          }
  
          // If a time zone is specified, all fields are interpreted as UTC and then
          // offset according to the specified time zone.
          if ("Z" in d) {
            d.H += d.Z / 100 | 0;
            d.M += d.Z % 100;
            return utcDate(d);
          }
  
          // Otherwise, all fields are in local time.
          return localDate(d);
        };
      }
      function parseSpecifier(d, specifier, string, j) {
        var i = 0,
          n = specifier.length,
          m = string.length,
          c,
          parse;
        while (i < n) {
          if (j >= m) return -1;
          c = specifier.charCodeAt(i++);
          if (c === 37) {
            c = specifier.charAt(i++);
            parse = parses[c in pads ? specifier.charAt(i++) : c];
            if (!parse || (j = parse(d, string, j)) < 0) return -1;
          } else if (c != string.charCodeAt(j++)) {
            return -1;
          }
        }
        return j;
      }
      function parsePeriod(d, string, i) {
        var n = periodRe.exec(string.slice(i));
        return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }
      function parseShortWeekday(d, string, i) {
        var n = shortWeekdayRe.exec(string.slice(i));
        return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }
      function parseWeekday(d, string, i) {
        var n = weekdayRe.exec(string.slice(i));
        return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }
      function parseShortMonth(d, string, i) {
        var n = shortMonthRe.exec(string.slice(i));
        return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }
      function parseMonth(d, string, i) {
        var n = monthRe.exec(string.slice(i));
        return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }
      function parseLocaleDateTime(d, string, i) {
        return parseSpecifier(d, locale_dateTime, string, i);
      }
      function parseLocaleDate(d, string, i) {
        return parseSpecifier(d, locale_date, string, i);
      }
      function parseLocaleTime(d, string, i) {
        return parseSpecifier(d, locale_time, string, i);
      }
      function formatShortWeekday(d) {
        return locale_shortWeekdays[d.getDay()];
      }
      function formatWeekday(d) {
        return locale_weekdays[d.getDay()];
      }
      function formatShortMonth(d) {
        return locale_shortMonths[d.getMonth()];
      }
      function formatMonth(d) {
        return locale_months[d.getMonth()];
      }
      function formatPeriod(d) {
        return locale_periods[+(d.getHours() >= 12)];
      }
      function formatQuarter(d) {
        return 1 + ~~(d.getMonth() / 3);
      }
      function formatUTCShortWeekday(d) {
        return locale_shortWeekdays[d.getUTCDay()];
      }
      function formatUTCWeekday(d) {
        return locale_weekdays[d.getUTCDay()];
      }
      function formatUTCShortMonth(d) {
        return locale_shortMonths[d.getUTCMonth()];
      }
      function formatUTCMonth(d) {
        return locale_months[d.getUTCMonth()];
      }
      function formatUTCPeriod(d) {
        return locale_periods[+(d.getUTCHours() >= 12)];
      }
      function formatUTCQuarter(d) {
        return 1 + ~~(d.getUTCMonth() / 3);
      }
      return {
        format: function format(specifier) {
          var f = newFormat(specifier += "", formats);
          f.toString = function () {
            return specifier;
          };
          return f;
        },
        parse: function parse(specifier) {
          var p = newParse(specifier += "", false);
          p.toString = function () {
            return specifier;
          };
          return p;
        },
        utcFormat: function utcFormat(specifier) {
          var f = newFormat(specifier += "", utcFormats);
          f.toString = function () {
            return specifier;
          };
          return f;
        },
        utcParse: function utcParse(specifier) {
          var p = newParse(specifier += "", true);
          p.toString = function () {
            return specifier;
          };
          return p;
        }
      };
    }
    var pads = {
        "-": "",
        "_": " ",
        "0": "0"
      },
      numberRe = /^\s*\d+/,
      // note: ignores next directive
      percentRe = /^%/,
      requoteRe = /[\\^$*+?|[\]().{}]/g;
    function pad(value, fill, width) {
      var sign = value < 0 ? "-" : "",
        string = (sign ? -value : value) + "",
        length = string.length;
      return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
    }
    function requote(s) {
      return s.replace(requoteRe, "\\$&");
    }
    function formatRe(names) {
      return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
    }
    function formatLookup(names) {
      return new Map(names.map(function (name, i) {
        return [name.toLowerCase(), i];
      }));
    }
    function parseWeekdayNumberSunday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 1));
      return n ? (d.w = +n[0], i + n[0].length) : -1;
    }
    function parseWeekdayNumberMonday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 1));
      return n ? (d.u = +n[0], i + n[0].length) : -1;
    }
    function parseWeekNumberSunday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.U = +n[0], i + n[0].length) : -1;
    }
    function parseWeekNumberISO(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.V = +n[0], i + n[0].length) : -1;
    }
    function parseWeekNumberMonday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.W = +n[0], i + n[0].length) : -1;
    }
    function parseFullYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 4));
      return n ? (d.y = +n[0], i + n[0].length) : -1;
    }
    function parseYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
    }
    function parseZone(d, string, i) {
      var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
      return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
    }
    function parseQuarter(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 1));
      return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
    }
    function parseMonthNumber(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
    }
    function parseDayOfMonth(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.d = +n[0], i + n[0].length) : -1;
    }
    function parseDayOfYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 3));
      return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
    }
    function parseHour24(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.H = +n[0], i + n[0].length) : -1;
    }
    function parseMinutes(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.M = +n[0], i + n[0].length) : -1;
    }
    function parseSeconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.S = +n[0], i + n[0].length) : -1;
    }
    function parseMilliseconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 3));
      return n ? (d.L = +n[0], i + n[0].length) : -1;
    }
    function parseMicroseconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 6));
      return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
    }
    function parseLiteralPercent(d, string, i) {
      var n = percentRe.exec(string.slice(i, i + 1));
      return n ? i + n[0].length : -1;
    }
    function parseUnixTimestamp(d, string, i) {
      var n = numberRe.exec(string.slice(i));
      return n ? (d.Q = +n[0], i + n[0].length) : -1;
    }
    function parseUnixTimestampSeconds(d, string, i) {
      var n = numberRe.exec(string.slice(i));
      return n ? (d.s = +n[0], i + n[0].length) : -1;
    }
    function formatDayOfMonth(d, p) {
      return pad(d.getDate(), p, 2);
    }
    function formatHour24(d, p) {
      return pad(d.getHours(), p, 2);
    }
    function formatHour12(d, p) {
      return pad(d.getHours() % 12 || 12, p, 2);
    }
    function formatDayOfYear(d, p) {
      return pad(1 + day.count(year(d), d), p, 3);
    }
    function formatMilliseconds(d, p) {
      return pad(d.getMilliseconds(), p, 3);
    }
    function formatMicroseconds(d, p) {
      return formatMilliseconds(d, p) + "000";
    }
    function formatMonthNumber(d, p) {
      return pad(d.getMonth() + 1, p, 2);
    }
    function formatMinutes(d, p) {
      return pad(d.getMinutes(), p, 2);
    }
    function formatSeconds(d, p) {
      return pad(d.getSeconds(), p, 2);
    }
    function formatWeekdayNumberMonday(d) {
      var day = d.getDay();
      return day === 0 ? 7 : day;
    }
    function formatWeekNumberSunday(d, p) {
      return pad(sunday.count(year(d) - 1, d), p, 2);
    }
    function dISO(d) {
      var day = d.getDay();
      return day >= 4 || day === 0 ? thursday(d) : thursday.ceil(d);
    }
    function formatWeekNumberISO(d, p) {
      d = dISO(d);
      return pad(thursday.count(year(d), d) + (year(d).getDay() === 4), p, 2);
    }
    function formatWeekdayNumberSunday(d) {
      return d.getDay();
    }
    function formatWeekNumberMonday(d, p) {
      return pad(monday.count(year(d) - 1, d), p, 2);
    }
    function formatYear(d, p) {
      return pad(d.getFullYear() % 100, p, 2);
    }
    function formatYearISO(d, p) {
      d = dISO(d);
      return pad(d.getFullYear() % 100, p, 2);
    }
    function formatFullYear(d, p) {
      return pad(d.getFullYear() % 10000, p, 4);
    }
    function formatFullYearISO(d, p) {
      var day = d.getDay();
      d = day >= 4 || day === 0 ? thursday(d) : thursday.ceil(d);
      return pad(d.getFullYear() % 10000, p, 4);
    }
    function formatZone(d) {
      var z = d.getTimezoneOffset();
      return (z > 0 ? "-" : (z *= -1, "+")) + pad(z / 60 | 0, "0", 2) + pad(z % 60, "0", 2);
    }
    function formatUTCDayOfMonth(d, p) {
      return pad(d.getUTCDate(), p, 2);
    }
    function formatUTCHour24(d, p) {
      return pad(d.getUTCHours(), p, 2);
    }
    function formatUTCHour12(d, p) {
      return pad(d.getUTCHours() % 12 || 12, p, 2);
    }
    function formatUTCDayOfYear(d, p) {
      return pad(1 + utcDay.count(utcYear(d), d), p, 3);
    }
    function formatUTCMilliseconds(d, p) {
      return pad(d.getUTCMilliseconds(), p, 3);
    }
    function formatUTCMicroseconds(d, p) {
      return formatUTCMilliseconds(d, p) + "000";
    }
    function formatUTCMonthNumber(d, p) {
      return pad(d.getUTCMonth() + 1, p, 2);
    }
    function formatUTCMinutes(d, p) {
      return pad(d.getUTCMinutes(), p, 2);
    }
    function formatUTCSeconds(d, p) {
      return pad(d.getUTCSeconds(), p, 2);
    }
    function formatUTCWeekdayNumberMonday(d) {
      var dow = d.getUTCDay();
      return dow === 0 ? 7 : dow;
    }
    function formatUTCWeekNumberSunday(d, p) {
      return pad(utcSunday.count(utcYear(d) - 1, d), p, 2);
    }
    function UTCdISO(d) {
      var day = d.getUTCDay();
      return day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
    }
    function formatUTCWeekNumberISO(d, p) {
      d = UTCdISO(d);
      return pad(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
    }
    function formatUTCWeekdayNumberSunday(d) {
      return d.getUTCDay();
    }
    function formatUTCWeekNumberMonday(d, p) {
      return pad(utcMonday.count(utcYear(d) - 1, d), p, 2);
    }
    function formatUTCYear(d, p) {
      return pad(d.getUTCFullYear() % 100, p, 2);
    }
    function formatUTCYearISO(d, p) {
      d = UTCdISO(d);
      return pad(d.getUTCFullYear() % 100, p, 2);
    }
    function formatUTCFullYear(d, p) {
      return pad(d.getUTCFullYear() % 10000, p, 4);
    }
    function formatUTCFullYearISO(d, p) {
      var day = d.getUTCDay();
      d = day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
      return pad(d.getUTCFullYear() % 10000, p, 4);
    }
    function formatUTCZone() {
      return "+0000";
    }
    function formatLiteralPercent() {
      return "%";
    }
    function formatUnixTimestamp(d) {
      return +d;
    }
    function formatUnixTimestampSeconds(d) {
      return Math.floor(+d / 1000);
    }
  
    var locale;
    var timeFormat;
    var timeParse;
    var utcFormat;
    var utcParse;
    defaultLocale({
      dateTime: "%x, %X",
      date: "%-m/%-d/%Y",
      time: "%-I:%M:%S %p",
      periods: ["AM", "PM"],
      days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
      shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
      shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
    });
    function defaultLocale(definition) {
      locale = formatLocale(definition);
      timeFormat = locale.format;
      timeParse = locale.parse;
      utcFormat = locale.utcFormat;
      utcParse = locale.utcParse;
      return locale;
    }
  
    var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";
    function formatIsoNative(date) {
      return date.toISOString();
    }
    var formatIso = Date.prototype.toISOString ? formatIsoNative : utcFormat(isoSpecifier);
  
    function parseIsoNative(string) {
      var date = new Date(string);
      return isNaN(date) ? null : date;
    }
    var parseIso = +new Date("2000-01-01T00:00:00.000Z") ? parseIsoNative : utcParse(isoSpecifier);
  
    function date$1(t) {
      return new Date(t);
    }
    function number$2(t) {
      return t instanceof Date ? +t : +new Date(+t);
    }
    function calendar(ticks, tickInterval, year, month, week, day, hour, minute, second, format) {
      var scale = continuous(),
        invert = scale.invert,
        domain = scale.domain;
      var formatMillisecond = format(".%L"),
        formatSecond = format(":%S"),
        formatMinute = format("%I:%M"),
        formatHour = format("%I %p"),
        formatDay = format("%a %d"),
        formatWeek = format("%b %d"),
        formatMonth = format("%B"),
        formatYear = format("%Y");
      function tickFormat(date) {
        return (second(date) < date ? formatMillisecond : minute(date) < date ? formatSecond : hour(date) < date ? formatMinute : day(date) < date ? formatHour : month(date) < date ? week(date) < date ? formatDay : formatWeek : year(date) < date ? formatMonth : formatYear)(date);
      }
      scale.invert = function (y) {
        return new Date(invert(y));
      };
      scale.domain = function (_) {
        return arguments.length ? domain(Array.from(_, number$2)) : domain().map(date$1);
      };
      scale.ticks = function (interval) {
        var d = domain();
        return ticks(d[0], d[d.length - 1], interval == null ? 10 : interval);
      };
      scale.tickFormat = function (count, specifier) {
        return specifier == null ? tickFormat : format(specifier);
      };
      scale.nice = function (interval) {
        var d = domain();
        if (!interval || typeof interval.range !== "function") interval = tickInterval(d[0], d[d.length - 1], interval == null ? 10 : interval);
        return interval ? domain(nice(d, interval)) : scale;
      };
      scale.copy = function () {
        return copy(scale, calendar(ticks, tickInterval, year, month, week, day, hour, minute, second, format));
      };
      return scale;
    }
    function time() {
      return initRange.apply(calendar(timeTicks, timeTickInterval, year, month, sunday, day, hour, minute, second, timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]), arguments);
    }
  
    // second, minute, hour, day, week, month, quarter, year
    var aggregateFormats = {
      second: '%Y-%m-%d %H:%M:%S',
      minute: '%Y-%m-%d %H:%M',
      hour: '%Y-%m-%d %H:00',
      day: '%Y-%m-%d',
      week: '%Y week %W',
      month: '%Y-%m',
      quarter: '%Y-Q%Q',
      year: '%Y'
    };
  
    function api (methods) {
      function methodChainer(wrapper, method) {
        return function (d) {
          method(d);
          return wrapper;
        };
      }
      return Object.keys(methods).reduce(function (API, methodName) {
        API[methodName] = methodChainer(API, methods[methodName]);
        return API;
      }, {});
    }
  
    var cssPrefix = 'milestones';
    var cssCategoryClass = cssPrefix + '__category_label';
    var cssHorizontalLineClass = cssPrefix + '__horizontal_line';
    var cssVerticalLineClass = cssPrefix + '__vertical_line';
    var cssGroupClass = cssPrefix + '__group';
    var cssBulletClass = cssGroupClass + '__bullet';
    var cssLabelClass = cssGroupClass + '__label';
    var cssLastClass = cssLabelClass + '-last';
    var cssAboveClass = cssLabelClass + '-above';
    var cssTextClass = cssLabelClass + '__text';
    var cssTitleClass = cssTextClass + '__title';
    var cssEventClass = cssTextClass + '__event';
    var cssEventHoverClass = cssEventClass + '--hover';
  
    var DEFAULTS = {
      DISTRIBUTION: 'top-bottom',
      OPTIMIZE: false,
      ORIENTATION: 'horizontal',
      MAPPING: {
        category: undefined,
        entries: undefined,
        timestamp: 'timestamp',
        text: 'text',
        url: 'url',
        textStyle: 'textStyle',
        titleStyle: 'titleStyle'
      },
      LABEL_FORMAT: '%Y-%m-%d %H:%M',
      USE_LABELS: true,
      AGGREGATE_BY: 'minute',
      AUTO_RESIZE: true,
      URL_TARGET: '_self'
    };
  
    function isAbove(i, distribution) {
      var above = i % 2;
      if (distribution === 'top') {
        above = true;
      } else if (distribution === 'bottom') {
        above = false;
      }
      return above > 0;
    }
  
    var prefix = "$";
    function Map$1() {}
    Map$1.prototype = map.prototype = {
      constructor: Map$1,
      has: function has(key) {
        return prefix + key in this;
      },
      get: function get(key) {
        return this[prefix + key];
      },
      set: function set(key, value) {
        this[prefix + key] = value;
        return this;
      },
      remove: function remove(key) {
        var property = prefix + key;
        return property in this && delete this[property];
      },
      clear: function clear() {
        for (var property in this) {
          if (property[0] === prefix) delete this[property];
        }
      },
      keys: function keys() {
        var keys = [];
        for (var property in this) {
          if (property[0] === prefix) keys.push(property.slice(1));
        }
        return keys;
      },
      values: function values() {
        var values = [];
        for (var property in this) {
          if (property[0] === prefix) values.push(this[property]);
        }
        return values;
      },
      entries: function entries() {
        var entries = [];
        for (var property in this) {
          if (property[0] === prefix) entries.push({
            key: property.slice(1),
            value: this[property]
          });
        }
        return entries;
      },
      size: function size() {
        var size = 0;
        for (var property in this) {
          if (property[0] === prefix) ++size;
        }
        return size;
      },
      empty: function empty() {
        for (var property in this) {
          if (property[0] === prefix) return false;
        }
        return true;
      },
      each: function each(f) {
        for (var property in this) {
          if (property[0] === prefix) f(this[property], property.slice(1), this);
        }
      }
    };
    function map(object, f) {
      var map = new Map$1();
  
      // Copy constructor.
      if (object instanceof Map$1) object.each(function (value, key) {
        map.set(key, value);
      });
  
      // Index array by numeric index or specified key function.
      else if (Array.isArray(object)) {
        var i = -1,
          n = object.length,
          o;
        if (f == null) while (++i < n) {
          map.set(i, object[i]);
        } else while (++i < n) {
          map.set(f(o = object[i], i, object), o);
        }
      }
  
      // Convert object to map.
      else if (object) for (var key in object) {
        map.set(key, object[key]);
      }
      return map;
    }
  
    function nest () {
      var keys = [],
        _sortKeys = [],
        _sortValues,
        _rollup,
        nest;
      function apply(array, depth, createResult, setResult) {
        if (depth >= keys.length) {
          if (_sortValues != null) array.sort(_sortValues);
          return _rollup != null ? _rollup(array) : array;
        }
        var i = -1,
          n = array.length,
          key = keys[depth++],
          keyValue,
          value,
          valuesByKey = map(),
          values,
          result = createResult();
        while (++i < n) {
          if (values = valuesByKey.get(keyValue = key(value = array[i]) + "")) {
            values.push(value);
          } else {
            valuesByKey.set(keyValue, [value]);
          }
        }
        valuesByKey.each(function (values, key) {
          setResult(result, key, apply(values, depth, createResult, setResult));
        });
        return result;
      }
      function _entries(map, depth) {
        if (++depth > keys.length) return map;
        var array,
          sortKey = _sortKeys[depth - 1];
        if (_rollup != null && depth >= keys.length) array = map.entries();else array = [], map.each(function (v, k) {
          array.push({
            key: k,
            values: _entries(v, depth)
          });
        });
        return sortKey != null ? array.sort(function (a, b) {
          return sortKey(a.key, b.key);
        }) : array;
      }
      return nest = {
        object: function object(array) {
          return apply(array, 0, createObject, setObject);
        },
        map: function map(array) {
          return apply(array, 0, createMap, setMap);
        },
        entries: function entries(array) {
          return _entries(apply(array, 0, createMap, setMap), 0);
        },
        key: function key(d) {
          keys.push(d);
          return nest;
        },
        sortKeys: function sortKeys(order) {
          _sortKeys[keys.length - 1] = order;
          return nest;
        },
        sortValues: function sortValues(order) {
          _sortValues = order;
          return nest;
        },
        rollup: function rollup(f) {
          _rollup = f;
          return nest;
        }
      };
    }
    function createObject() {
      return {};
    }
    function setObject(object, key, value) {
      object[key] = value;
    }
    function createMap() {
      return map();
    }
    function setMap(map, key, value) {
      map.set(key, value);
    }
  
    function Set() {}
    var proto = map.prototype;
    Set.prototype = set.prototype = {
      constructor: Set,
      has: proto.has,
      add: function add(value) {
        value += "";
        this[prefix + value] = value;
        return this;
      },
      remove: proto.remove,
      clear: proto.clear,
      values: proto.keys,
      size: proto.size,
      empty: proto.empty,
      each: proto.each
    };
    function set(object, f) {
      var set = new Set();
  
      // Copy constructor.
      if (object instanceof Set) object.each(function (value) {
        set.add(value);
      });
  
      // Otherwise, assume it’s an array.
      else if (object) {
        var i = -1,
          n = object.length;
        if (f == null) while (++i < n) {
          set.add(object[i]);
        } else while (++i < n) {
          set.add(f(object[i], i, object));
        }
      }
      return set;
    }
  
    function getAttribute(d, attribute) {
      return parseInt(d.style[attribute].replace('px', ''), 10);
    }
  
    var labelRightMargin = 6;
    var getAvailableWidth = function getAvailableWidth(aggregateFormatParse, currentNode, index, mapping, nestedData, nestedNode, nextCheck, nextGroupHeight, offset, offsetCheckAttribute, offsetAttribute, orientation, textMerge, width, x) {
      var useNext = arguments.length > 15 && arguments[15] !== undefined ? arguments[15] : true;
      // get the available width until the uber-next group
      var nextTestIndex = orientation === 'horizontal' && useNext ? index + nextCheck : index - nextCheck;
      var nextTestItem;
      do {
        if (orientation === 'horizontal' && useNext) {
          nextTestIndex += nextCheck;
        } else {
          nextTestIndex -= nextCheck;
        }
        nextTestItem = textMerge._groups[nextTestIndex];
        if (typeof nextTestItem === 'undefined') {
          break;
        }
      } while (nextGroupHeight >= nextTestItem[0][offsetAttribute]);
      var uberNextItem;
      if (typeof mapping.category === 'undefined') {
        uberNextItem = nestedData[nestedNode.timelineIndex][nextTestIndex];
      } else {
        uberNextItem = nestedData[nestedNode.timelineIndex].entries[nextTestIndex];
      }
      var availableWidth = getAttribute(currentNode, offsetCheckAttribute);
      if (typeof uberNextItem !== 'undefined') {
        var offsetUberNextItem = x(aggregateFormatParse(uberNextItem.key));
        if (orientation === 'horizontal' & useNext) {
          availableWidth = offsetUberNextItem - offset - labelRightMargin;
        } else if (orientation === 'horizontal' & !useNext) {
          availableWidth = offsetUberNextItem - labelRightMargin;
        } else {
          availableWidth = offset - offsetUberNextItem - labelRightMargin;
        }
      } else {
        if (orientation === 'horizontal' & useNext) {
          availableWidth = width - offset - labelRightMargin;
        } else if (orientation === 'horizontal' & !useNext) {
          availableWidth = offset - labelRightMargin;
        } else {
          availableWidth = offset - labelRightMargin;
        }
      }
      if (nextCheck < 0) {
        return Math.min(offset, availableWidth);
      } else {
        return availableWidth;
      }
    };
  
    var getNextGroup = function getNextGroup(orientation, nodes, index, nextCheck) {
      var nextGroup = orientation === 'horizontal' ? nodes[index + nextCheck] : nodes[index - nextCheck];
      return nextGroup;
    };
    var getNextGroupHeight = function getNextGroupHeight(index, nextCheck, nodes, offsetAttribute, orientation) {
      // get the height of the next group
      var defaultPadding = 3;
      var nextGroup = getNextGroup(orientation, nodes, index, nextCheck);
      var nextGroupHeight = 0;
      if (typeof nextGroup !== 'undefined') {
        nextGroupHeight = nextGroup[0][offsetAttribute] + defaultPadding;
      }
      return nextGroupHeight;
    };
  
    var MAX_OPTIMIZER_RUNS = 20;
    var getIntValueFromPxAttribute = function getIntValueFromPxAttribute(domElement, attribute) {
      return parseInt(domElement.style(attribute).replace('px', ''), 10);
    };
    var getParentElement = function getParentElement(domElement) {
      return domElement.select(function () {
        return this.parentNode;
      });
    };
    var isSameDistribution = function isSameDistribution(index, nextCheck, overlapCheckIndex) {
      var itemRowCheck = index % nextCheck;
      var distributionCheck = (overlapCheckIndex + itemRowCheck) % nextCheck;
      return distributionCheck !== 0;
    };
    var optimize = function optimize(aggregateFormatParse, distribution, labelMaxWidth, mapping, nestedData, orientation, textMerge, width, widthAttribute, x) {
      var nestedNodes = nest().key(function (d) {
        return selectAll(d).data()[0].timelineIndex;
      }).entries(textMerge._groups);
      var nextCheck = distribution === 'top-bottom' ? 2 : 1;
      var runOptimizer = function runOptimizer(optimizerRuns) {
        var updated = 0;
        nestedNodes.forEach(function (d) {
          var nodes = d.values;
          nodes.forEach(function (node) {
            var d = selectAll(node).data()[0];
            var offsetComparator = orientation === 'horizontal' ? 60 : 20;
            var index = orientation === 'horizontal' ? nodes.length - d.index - 1 : d.index;
            var item = selectAll(nodes[index]).data()[0];
            var offset = x(aggregateFormatParse(item.key));
            var currentNode = nodes[index][0];
            var isLast = index === nodes.length - 1;
            if (!isLast && distribution === 'top-bottom') {
              isLast = index === nodes.length - 2 && width - offset < 60;
            }
            var scrollCheckAttribute = orientation === 'horizontal' ? 'offsetWidth' : 'offsetHeight';
            var offsetCheckAttribute = orientation === 'horizontal' ? 'width' : 'height';
            var offsetCheck = getAttribute(currentNode, offsetCheckAttribute);
            var domElement = selectAll(nodes[index]);
            var backwards = isLast ? true : getParentElement(domElement).classed(cssLastClass);
            var offsetAttribute = orientation === 'horizontal' ? 'offsetHeight' : 'offsetWidth';
            var paddingAbove = orientation === 'horizontal' ? 'padding-bottom' : 'padding-right';
            var paddingBelow = orientation === 'horizontal' ? 'padding-top' : 'padding-left';
            var padding = isAbove(index, distribution) ? paddingAbove : paddingBelow;
            var overflow = backwards ? offset - offsetCheck < 0 : offset + offsetCheck > width;
  
            // Because on a resize a previous optimization could already have
            // repositioned items, we reset them on the first optimizer run
            if (optimizerRuns === 0) {
              backwards = isLast ? true : overflow;
              domElement.style(padding, '0px');
              getParentElement(domElement).classed(cssLastClass, backwards);
            }
            if (currentNode[scrollCheckAttribute] > offsetCheck || offsetCheck < offsetComparator || backwards || overflow) {
              var availableWidth = null;
              var runs = 0;
              var nextCheckIterator = orientation === 'horizontal' ? nextCheck - 1 : nextCheck + 1;
              do {
                if (orientation === 'horizontal') {
                  nextCheckIterator++;
                } else {
                  nextCheckIterator--;
                }
                runs++;
                if (nextCheckIterator > 0) {
                  var nextGroupHeight = getNextGroupHeight(index, nextCheck, nodes, offsetAttribute, orientation);
                  var previousGroupHeight = orientation === 'horizontal' ? getNextGroupHeight(index, nextCheck * -1, nodes, offsetAttribute, orientation) : nextGroupHeight;
                  var useNext = nextGroupHeight <= previousGroupHeight && !isLast;
                  if (!useNext && !isLast) {
                    useNext = offset < offsetComparator;
                  }
                  var groupHeight = useNext ? nextGroupHeight : previousGroupHeight;
                  if (isLast) {
                    groupHeight = 0;
                  }
                  var check = useNext ? nextCheck : nextCheck * -1;
                  domElement.style(padding, groupHeight + 'px');
                  getParentElement(domElement).classed(cssLastClass, !useNext);
                  availableWidth = getAvailableWidth(aggregateFormatParse, currentNode, index, mapping, nestedData, d, check, groupHeight, offset, offsetCheckAttribute, offsetAttribute, orientation, textMerge, width, x, useNext);
                }
              } while (availableWidth < currentNode[scrollCheckAttribute] && runs < MAX_OPTIMIZER_RUNS);
              if (orientation === 'horizontal') {
                availableWidth = Math.min(labelMaxWidth, availableWidth);
              }
  
              // because labels could be left or right aligned,
              // we shrink the available width to the inner text width
              // so labels facing each other will require less space.
              domElement.style(widthAttribute, availableWidth + 'px');
              var innerWidth = getIntValueFromPxAttribute(domElement.select('.wrapper'), 'width');
              if (innerWidth < availableWidth) {
                availableWidth = innerWidth + 6;
                domElement.style(widthAttribute, availableWidth + 'px');
              }
              if (optimizerRuns > 0 && orientation === 'horizontal') {
                var itemWidth = getIntValueFromPxAttribute(domElement, 'width');
                var checkOffset = backwards ? offset - itemWidth : offset + itemWidth;
                nodes.forEach(function (overlapCheckNode, overlapCheckIndex) {
                  var overlapCheckItem = selectAll(overlapCheckNode).data()[0];
                  if (overlapCheckItem.key === item.key || isSameDistribution(index, nextCheck, overlapCheckIndex)) {
                    return;
                  }
                  var overlapCheckOffset = x(aggregateFormatParse(overlapCheckItem.key)) - 5;
                  var overlapItemOffsetAnchor = overlapCheckOffset;
                  var overlapCheckDomElement = selectAll(nodes[overlapCheckIndex]);
                  var overlapCheckBackwards = getParentElement(overlapCheckDomElement).classed(cssLastClass);
                  if (backwards && !overlapCheckBackwards) {
                    var overlapCheckItemWidth = getIntValueFromPxAttribute(overlapCheckDomElement, 'width');
                    overlapCheckOffset = overlapCheckOffset + overlapCheckItemWidth + 5;
                  }
                  if (!backwards && overlapCheckBackwards) {
                    var _overlapCheckItemWidth = getIntValueFromPxAttribute(overlapCheckDomElement, 'width');
                    overlapCheckOffset = overlapCheckOffset - _overlapCheckItemWidth - 5;
                  }
                  var overlapCheck1 = backwards ? overlapCheckOffset > checkOffset : checkOffset > overlapItemOffsetAnchor;
                  var overlapCheck2 = backwards ? overlapItemOffsetAnchor < offset : overlapItemOffsetAnchor > offset;
                  if (overlapCheck1 && overlapCheck2) {
                    var overlapCheckHeight = overlapCheckNode[0][offsetAttribute];
                    var itemPadding = getIntValueFromPxAttribute(domElement, padding);
                    if (itemPadding < overlapCheckHeight) {
                      // offsetComparator
                      // find out if there's enough place to get rid of overlap
                      // by adjusted the items width
                      var checkWidth = backwards ? overlapCheckOffset - checkOffset : checkOffset - overlapItemOffsetAnchor;
                      var currentWidth = getIntValueFromPxAttribute(domElement, widthAttribute);
                      var reducedWidth = currentWidth - checkWidth - 6;
                      if (reducedWidth > offsetComparator) {
                        availableWidth = Math.min(availableWidth, reducedWidth);
                        domElement.style(widthAttribute, "".concat(availableWidth, "px"));
                      } else {
                        domElement.style(padding, "".concat(overlapCheckHeight + 5, "px"));
                      }
                      updated++;
                    }
                  }
                });
  
                // The optimizer might push all labels too far up. If all labels
                // have a minimum padding of more than 0, we'll shrink all offsets
                // back so the label with the smallest padding ends up directly
                // at the timeline.
  
                var minPadding = Number.POSITIVE_INFINITY;
                nodes.forEach(function (overlapCheckNode, overlapCheckIndex) {
                  var checkSameOrientation = isAbove(overlapCheckIndex, distribution) ? paddingAbove : paddingBelow;
                  if (checkSameOrientation !== padding) {
                    return;
                  }
                  var overlapCheckDomElement = selectAll(nodes[overlapCheckIndex]);
                  var itemPadding = getIntValueFromPxAttribute(overlapCheckDomElement, padding);
                  minPadding = Math.min(minPadding, itemPadding);
                });
                if (minPadding > 0) {
                  nodes.forEach(function (overlapCheckNode, overlapCheckIndex) {
                    var itemRowCheck = index % nextCheck;
                    var distributionCheck = (overlapCheckIndex + itemRowCheck) % nextCheck;
                    if (distributionCheck !== 0) {
                      return;
                    }
                    var overlapCheckDomElement = selectAll(nodes[overlapCheckIndex]);
                    var itemPadding = getIntValueFromPxAttribute(overlapCheckDomElement, padding);
                    overlapCheckDomElement.style(padding, "".concat(itemPadding - minPadding, "px"));
                  });
                }
              }
            }
          });
        });
        return updated;
      };
      var optimizerRuns = 0;
      var updated = 0;
      do {
        updated = runOptimizer(optimizerRuns);
        optimizerRuns++;
  
        // make sure we run a second optimizer call
        if (optimizerRuns === 1) {
          updated = 1;
        }
      } while (optimizerRuns < MAX_OPTIMIZER_RUNS && updated > 0);
    };
  
    function timeFormat$1(f) {
      if (f === '%Y-Q%Q') {
        var quarterFormatter = timeFormat(aggregateFormats.month);
        return function (d) {
          var formattedDate = quarterFormatter(d);
          var month = formattedDate.split('-')[1];
          var quarter = Math.ceil(parseInt(month) / 3);
          return formattedDate.split('-')[0] + '-Q' + quarter;
        };
      }
      return timeFormat(f);
    }
  
    function timeParse$1(f) {
      if (f === '%Y-Q%Q') {
        var quarterParser = timeParse(aggregateFormats.month);
        return function (d) {
          if (d.search('-Q') === -1) {
            var quarter = Math.ceil(parseInt(d.split('-')[1]) / 3);
            var quarterFirstMonthAsString = quarter * 3 - 2 + '';
            var quarterFirstMonthLeadingZero = quarterFirstMonthAsString.length < 2 ? '0' + quarterFirstMonthAsString : quarterFirstMonthAsString;
            return quarterParser(d.split('-')[0] + '-' + quarterFirstMonthLeadingZero);
          } else {
            var monthAsString = parseInt(d.split('-')[1][1]) * 3 + '';
            var monthLeadingZero = monthAsString.length < 2 ? '0' + monthAsString : monthAsString;
            return quarterParser(d.split('-')[0] + '-' + monthLeadingZero);
          }
        };
      }
      return timeParse(f);
    }
  
    function transform(aggregateFormat, data, mapping, parseTime) {
      var groupBy = function groupBy(d) {
        return aggregateFormat(parseTime(d[mapping.timestamp]));
      };
  
      // test for different data structures
      if (typeof mapping.category !== 'undefined' && typeof mapping.entries !== 'undefined') {
        data = data.map(function (timeline, timelineIndex) {
          return {
            category: timeline[mapping.category],
            entries: getNestedEntries(timeline[mapping.entries], timelineIndex)
          };
        });
        return data;
      } else if (typeof data !== 'undefined' && !Array.isArray(data[0])) {
        data = [data];
      }
      function getNestedEntries(t, tI) {
        var nested = nest().key(groupBy).sortKeys(ascending$1).entries(t);
        return nested.map(function (d, dI) {
          d.index = dI;
          d.timelineIndex = tI;
          return d;
        });
      }
      return data.map(function (t, tI) {
        return getNestedEntries(t, tI);
      });
    }
  
    function milestones(selector) {
      var distribution = DEFAULTS.DISTRIBUTION;
      function setDistribution(d) {
        distribution = d;
      }
      var optimizeLayout = DEFAULTS.OPTIMIZE;
      function setOptimizeLayout(d) {
        optimizeLayout = d;
      }
      var orientation = DEFAULTS.ORIENTATION;
      function setOrientation(d) {
        orientation = d;
        // purge the DOM to avoid layout issues when switching orientation
        select(selector).html('');
      }
      var parseTime = parseIso;
      function setParseTime(d) {
        parseTime = timeParse$1(d);
      }
      var mapping = Object.assign({}, DEFAULTS.MAPPING);
      function assignMapping(d) {
        mapping = Object.assign({}, mapping, d);
      }
      var labelFormat;
      function setLabelFormat(d) {
        labelFormat = timeFormat$1(d);
      }
      setLabelFormat(DEFAULTS.LABEL_FORMAT);
      var range;
      function setRange(d) {
        if (Array.isArray(d) && d.length == 2) {
          range = d;
        }
      }
      var useLabels;
      function setUseLabels(d) {
        useLabels = d;
      }
      setUseLabels(DEFAULTS.USE_LABELS);
      var urlTarget;
      function setUrlTarget(d) {
        if (typeof d === 'string' && ['_blank', '_self', '_parent', '_top'].includes(d.toLowerCase())) {
          urlTarget = d;
        }
      }
      setUrlTarget(DEFAULTS.URL_TARGET);
  
      // set callback for event mouseover
      var callBackMouseOver;
      function setEventMouseOverCallback(callback) {
        callBackMouseOver = callback;
      }
      function eventMouseOver(d) {
        if (typeof callBackMouseOver === 'function') {
          select(this).classed(cssEventHoverClass, true);
          callBackMouseOver(d);
        }
        return d;
      }
  
      // set callback for event mouseleave
      var callBackMouseLeave;
      function setEventMouseLeaveCallback(callback) {
        callBackMouseLeave = callback;
      }
      function eventMouseLeave(d) {
        if (typeof callBackMouseOver === 'function') {
          select(this).classed(cssEventHoverClass, false);
          callBackMouseLeave(d);
        }
        return d;
      }
  
      // set callback for event click
      var callbackClick;
      function setEventClickCallback(callback) {
        callbackClick = callback;
      }
      function eventClick(d) {
        if (typeof callbackClick === 'function') {
          callbackClick(d);
        }
        return d;
      }
      var aggregateFormat = timeFormat$1(aggregateFormats[DEFAULTS.AGGREGATE_BY]);
      var aggregateFormatParse = timeParse$1(aggregateFormats[DEFAULTS.AGGREGATE_BY]);
      function setAggregateBy(d) {
        aggregateFormat = timeFormat$1(aggregateFormats[d]);
        aggregateFormatParse = timeParse$1(aggregateFormats[d]);
        setLabelFormat(aggregateFormats[d]);
      }
      var autoResize = {
        current: DEFAULTS.AUTO_RESIZE
      };
      var resizeHandler = function resizeHandler() {
        if (select(selector).node() !== null) {
          window.requestAnimationFrame(function () {
            if (autoResize.current) {
              render();
            }
          });
        }
      };
      var resizeObserver = new ResizeObserver(resizeHandler);
      resizeObserver.observe(typeof selector === 'string' ? document.querySelector(selector) : selector);
      function setAutoResize(d) {
        autoResize.current = d;
      }
      function render(data) {
        var widthAttribute = orientation === 'horizontal' ? 'width' : 'height';
        var marginTimeAttribute = orientation === 'horizontal' ? 'margin-left' : 'margin-top';
        var cssLineClass = orientation === 'horizontal' ? cssHorizontalLineClass : cssVerticalLineClass;
        var labelMaxWidth = orientation === 'horizontal' ? 180 : 100;
        var timelineSelection = select(selector).selectAll('.' + cssPrefix);
        var nestedData = typeof data !== 'undefined' ? transform(aggregateFormat, data, mapping, parseTime) : timelineSelection.data();
        var timeline = timelineSelection.data(nestedData);
        var timelineEnter = timeline.enter().append('div').attr('class', cssPrefix);
        timeline.exit().remove();
  
        // rightMargin compensates for the right most bullet position
        var rightMargin = 11;
        var selectorWidth = parseFloat(select(selector).style(widthAttribute)) - rightMargin;
        if (typeof mapping.category !== 'undefined') {
          timelineEnter.append('div').attr('class', cssCategoryClass).text(function (d) {
            return d.category;
          });
          timelineEnter.append('div').attr('class', 'data-js-timeline').append('div').attr('class', cssLineClass);
        } else {
          timelineEnter.append('div').attr('class', cssLineClass);
        }
        var timelineMerge = timeline.merge(timelineEnter);
        var categoryLabelWidths = [];
        var categoryLabels = timelineMerge.selectAll('.' + cssCategoryClass);
        categoryLabels.each(function (d, i, node) {
          categoryLabelWidths.push(node[i].offsetWidth);
        });
        var maxCategoryLabelWidth = Math.round(max(categoryLabelWidths) || 0);
        var timelineLeftMargin = 10;
        var width = selectorWidth - maxCategoryLabelWidth - timelineLeftMargin;
        categoryLabels.style('width', maxCategoryLabelWidth + 'px');
        if (orientation === 'vertical') {
          categoryLabels.style('margin-left', '-50%');
          categoryLabels.style('text-align', 'center');
        }
        timelineMerge.selectAll('.data-js-timeline').style(marginTimeAttribute, maxCategoryLabelWidth + timelineLeftMargin + 'px');
        timelineMerge.selectAll('.' + cssLineClass).style(widthAttribute, width + 'px');
        var groupSelector = typeof mapping.category === 'undefined' ? timelineMerge : timelineMerge.selectAll('.data-js-timeline');
        var groupSelection = groupSelector.selectAll('.' + cssGroupClass);
        var group = groupSelection.data(function (d) {
          return typeof mapping.category === 'undefined' ? d : d.entries;
        });
        var allKeys = nestedData.reduce(function (keys, timeline) {
          var t = typeof mapping.category === 'undefined' ? timeline : timeline.entries;
          t.map(function (d) {
            return keys.push(d.key);
          });
          return keys;
        }, []);
        var domain = typeof range !== 'undefined' ? range.map(aggregateFormatParse) : extent(allKeys, function (d) {
          return aggregateFormatParse(d);
        });
        var x = time().rangeRound([0, width])
        // sets oldest and newest date as the scales domain
        .domain(domain);
        var groupEnter = group.enter().append('div').attr('class', cssGroupClass);
        group.exit().remove();
        groupEnter.append('div').attr('class', cssBulletClass);
        var groupMerge = groupEnter.merge(group).style(marginTimeAttribute, function (d) {
          return x(aggregateFormatParse(d.key)) + 'px';
        });
        if (useLabels) {
          var label = groupMerge.selectAll('.' + cssLabelClass + '-' + orientation).data(function (d) {
            return [d];
          });
          var labelMerge = label.enter().append('div').attr('class', cssLabelClass + '-' + orientation).merge(label)
          // .classed(cssLastClass, (d) => {
          //   const mostRightPosition = Math.round(x.range()[1]);
          //   const currentPosition = x(aggregateFormatParse(d.key));
          //   return (
          //     mostRightPosition === currentPosition &&
          //     orientation === 'horizontal'
          //   );
          // })
          .classed(cssAboveClass + '-' + orientation, function (d) {
            return isAbove(d.index, distribution);
          });
          var text = labelMerge.selectAll('.' + cssTextClass + '-' + orientation).data(function (d) {
            return [d];
          });
          var textEnter = text.enter().append('div').attr('class', cssTextClass + '-' + orientation).merge(text).style(widthAttribute, function (d) {
            // calculate the available width
            var offset = x(aggregateFormatParse(d.key));
            // get the next and previous item on the same lane
            var nextItem;
            var previousItem;
            var itemNumTotal;
            var itemNum = d.index + 1;
            var nextCheck = distribution === 'top-bottom' ? 2 : 1;
            if (typeof mapping.category === 'undefined') {
              nextItem = nestedData[d.timelineIndex][d.index + nextCheck];
              previousItem = nestedData[d.timelineIndex][d.index - nextCheck];
              itemNumTotal = nestedData[d.timelineIndex].length;
            } else {
              nextItem = nestedData[d.timelineIndex].entries[d.index + nextCheck];
              previousItem = nestedData[d.timelineIndex].entries[d.index - nextCheck];
              itemNumTotal = nestedData[d.timelineIndex].entries.length;
            }
            var availableWidth;
            var compareItem1 = orientation === 'horizontal' ? nextItem : previousItem;
            var compareItem2 = orientation === 'horizontal' ? previousItem : nextItem;
            if (typeof compareItem1 !== 'undefined') {
              var offsetNextItem = x(aggregateFormatParse(compareItem1.key));
              availableWidth = orientation === 'horizontal' ? offsetNextItem - offset : offset - offsetNextItem;
              if (itemNumTotal - itemNum === 2) {
                availableWidth /= 2;
              }
            } else {
              if (itemNumTotal - itemNum === 1) {
                availableWidth = orientation === 'horizontal' ? width - offset : offset;
              } else if (itemNumTotal - itemNum === 0) {
                if (typeof compareItem2 !== 'undefined') {
                  var offsetPreviousItem = x(aggregateFormatParse(compareItem2.key));
                  availableWidth = orientation === 'horizontal' ? (width - offsetPreviousItem) / 2 : offsetPreviousItem / 2;
                } else {
                  availableWidth = width;
                }
              }
            }
            var labelRightMargin = 6;
            var availableWidthWithMargin = Math.max(0, availableWidth - labelRightMargin);
            var finalWidth = Math.min(orientation === 'horizontal' ? labelMaxWidth : availableWidthWithMargin, availableWidthWithMargin);
            return finalWidth + 'px';
          }).each(function (d) {
            var above = isAbove(d.index, distribution);
            var wrapper = select(this);
            wrapper.html(null);
            var titleStyle = d.values.reduce(function (p, c) {
              if (c[mapping.titleStyle] !== undefined) {
                return Object.assign(p, c[mapping.titleStyle]);
              }
              return p;
            }, {});
            var element = wrapper.append('div').classed('wrapper', true);
            if (!above || orientation === 'vertical') {
              var titleSpan = element.append('span').classed(cssTitleClass, true).text(labelFormat(aggregateFormatParse(d.key)));
              Object.entries(titleStyle).forEach(function (_ref) {
                var _ref2 = _slicedToArray(_ref, 2),
                  prop = _ref2[0],
                  val = _ref2[1];
                return titleSpan.style(prop, val);
              });
              element.append('br');
            }
            d.values.map(function (v, i) {
              if (i > 0) {
                element.append('br');
              }
              var textStyle = Object.assign({}, v[mapping.textStyle]);
              var t = v[mapping.text];
              var item;
              // test if text is an image filename,
              // if so return an image tag with the filename as the source
              if (['jpg', 'jpeg', 'gif', 'png'].indexOf(t.split('.').pop()) > -1) {
                item = element.append('img').classed('milestones-label', true).classed('milestones-image-label', true).attr('height', '100').attr('src', t);
              } else if (v[mapping.url]) {
                item = element.append('a').classed('milestones-label', true).classed('milestones-link-label', true).attr('href', v[mapping.url]).attr('target', urlTarget)
                item._groups[0][0].append($(t)[0])
              } else {
                item = element.append('span').classed('milestones-label', true).classed('milestones-text-label', true);
                item._groups[0][0].append($(t)[0]) 
              }
              item.datum({
                text: v[mapping.text],
                timestamp: v[mapping.timestamp],
                attributes: v // original value of an object passed to the milestone
              });
  
              if (typeof callbackClick === 'function' || typeof callBackMouseLeave === 'function' || typeof callBackMouseOver === 'function') {
                item.classed(cssEventClass, true);
              }
              if (typeof callbackClick === 'function') {
                item.on('click', eventClick);
              }
              if (typeof callBackMouseLeave === 'function') {
                item.on('mouseleave', eventMouseLeave);
              }
              if (typeof callBackMouseOver === 'function') {
                item.on('mouseover', eventMouseOver);
              }
              Object.entries(textStyle).forEach(function (_ref3) {
                var _ref4 = _slicedToArray(_ref3, 2),
                  prop = _ref4[0],
                  val = _ref4[1];
                return item.style(prop, val);
              });
            });
            if (above && orientation === 'horizontal') {
              element.append('br');
              var _titleSpan = element.append('span').classed(cssTitleClass, true).text(labelFormat(aggregateFormatParse(d.key)));
              Object.entries(titleStyle).forEach(function (_ref5) {
                var _ref6 = _slicedToArray(_ref5, 2),
                  prop = _ref6[0],
                  val = _ref6[1];
                return _titleSpan.style(prop, val);
              });
            }
          });
          var textMerge = text.merge(textEnter);
          textMerge.style('padding-top', '0px').style('padding-bottom', '0px');
          if (optimizeLayout) {
            optimize(aggregateFormatParse, distribution, labelMaxWidth, mapping, nestedData, orientation, textMerge, width, widthAttribute, x);
          }
        } else {
          groupMerge.selectAll('.' + cssLabelClass + '-' + orientation).remove();
        }
  
        // finally, adjust offset, height and width of the whole timeline
        timelineMerge.each(function (d, i, node) {
          var margin = 10;
          var maxAboveHeight = max(select(node[i]).selectAll('* .' + cssAboveClass + '-' + orientation)._groups[0], function (d) {
            return d.offsetHeight;
          });
          var maxBelowHeight = max(select(node[i]).selectAll('* :not(.' + cssAboveClass + '-' + orientation + ')')._groups[0], function (d) {
            return d.offsetHeight;
          });
          if (orientation === 'horizontal') {
            select(node[i]).style('margin-top', margin + (maxAboveHeight || 0) + 'px').style('height', margin + (maxBelowHeight || 0) + 'px');
          } else {
            var percent = typeof mapping.category !== 'undefined' ? Math.round(100 / (nestedData.length + 1)) * (i + 1) : '50';
            select(node[i]).style('margin-top', '50px').style('margin-left', percent + '%').style('position', 'absolute');
          }
        });
      }
      return api({
        aggregateBy: setAggregateBy,
        mapping: assignMapping,
        optimize: setOptimizeLayout,
        autoResize: setAutoResize,
        orientation: setOrientation,
        distribution: setDistribution,
        parseTime: setParseTime,
        labelFormat: setLabelFormat,
        urlTarget: setUrlTarget,
        useLabels: setUseLabels,
        range: setRange,
        render: render,
        onEventClick: setEventClickCallback,
        onEventMouseLeave: setEventMouseLeaveCallback,
        onEventMouseOver: setEventMouseOverCallback
      });
    }
  
    return milestones;
  
  })));
  //# sourceMappingURL=d3-milestones.js.map
  
  